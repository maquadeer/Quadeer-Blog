[{"content":"","date":"10 November 2023","permalink":"/","section":"Abdul Quadeer's blog","summary":"","title":"Abdul Quadeer's blog"},{"content":"    Click test-gpt to view detailed explanation of below programs.   Program-1 : Network Command Explanation #   tcpdump  tcpdump is a packet analyzer tool that allows you to capture and analyze network traffic. You can adjust the interface and packet count as needed for your specific use case.\n netstat  netstat is a command-line utility for displaying network statistics, including open ports and active network connections. The command netstat -tuln shows listening TCP and UDP ports.\n ifconfig  ifconfig is used to display and configure network interface parameters, including IP addresses, netmasks, and more. It provides information about the network interfaces on your system.\n nslookup  nslookup is a network utility for performing DNS (Domain Name System) lookups. In the provided example, it performs a DNS lookup for \u0026lsquo;example.com\u0026rsquo;, returning information about the domain\u0026rsquo;s IP addresses.\n FTP  FTP *(File Transfer Protocol) is a network protocol used for transferring files between a client and a server. To interact with FTP programmatically, you should use dedicated FTP client libraries in C, as the command-line ftp client may not be suitable for automation.\n TELNET  T*ELNET is a network protocol that allows terminal access to remote systems. To interact with TELNET servers programmatically, you\u0026rsquo;ll need to use a TELNET library or API, as it\u0026rsquo;s not straightforward to automate using a command-line program.\n traceroute  traceroute is a network diagnostic tool used to trace the route that packets take from your computer to a destination host (e.g., \u0026lsquo;example.com\u0026rsquo;). It displays a list of intermediate routers and their response times.\nPlease note that some of these services/commands may require additional configuration, and some may not be available on all systems. The specific options and usage may vary depending on your operating system and network setup.\n   Iâ€™ve tried making a program demonstrating all these commands  // Program containing all commands in switch #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { int choice; while (1) { printf(\u0026#34;Select an option:\\n\u0026#34;); printf(\u0026#34;1. Run tcpdump\\n\u0026#34;); printf(\u0026#34;2. Run netstat\\n\u0026#34;); printf(\u0026#34;3. Run ifconfig\\n\u0026#34;); printf(\u0026#34;4. Run nslookup\\n\u0026#34;); printf(\u0026#34;5. Run FTP\\n\u0026#34;); printf(\u0026#34;6. Run TELNET\\n\u0026#34;); printf(\u0026#34;7. Run traceroute\\n\u0026#34;); printf(\u0026#34;8. Exit\\n\u0026#34;); printf(\u0026#34;Enter your choice: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); switch (choice) { case 1: system(\u0026#34;tcpdump -i eth0\u0026#34;); // Replace \u0026#39;eth0\u0026#39; with your network interface  break; case 2: system(\u0026#34;netstat -tuln\u0026#34;); break; case 3: system(\u0026#34;ifconfig\u0026#34;); break; case 4: printf(\u0026#34;Enter the hostname to look up: \u0026#34;); char hostname[256]; scanf(\u0026#34;%s\u0026#34;, hostname); char nslookupCommand[256]; sprintf(nslookupCommand, \u0026#34;nslookup %s\u0026#34;, hostname); system(nslookupCommand); break; case 5: system(\u0026#34;ftp\u0026#34;); // This will start an interactive FTP session  break; case 6: system(\u0026#34;telnet\u0026#34;); // This will start an interactive TELNET session  break; case 7: printf(\u0026#34;Enter the destination IP or hostname for traceroute: \u0026#34;); char dest[256]; scanf(\u0026#34;%s\u0026#34;, dest); char tracerouteCommand[256]; sprintf(tracerouteCommand, \u0026#34;traceroute %s\u0026#34;, dest); system(tracerouteCommand); break; case 8: exit(0); default: printf(\u0026#34;Invalid choice. Please try again.\\n\u0026#34;); } } return 0; }  Program-2a,2b,2c : UDP-client #  #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;sys/socket.h\u0026gt;#include\u0026lt;netinet/in.h\u0026gt;#include\u0026lt;sys/types.h\u0026gt;#include\u0026lt;string.h\u0026gt;main(int argc, char * argv[]) { struct sockaddr_in s; int rval,sockid,slen; char m1[20],m2[20]; system(\u0026#34;clear\u0026#34;); if(argc\u0026lt;3) { printf(\u0026#34;\\nUSAGE : %s IP_Address port \\n\u0026#34;,argv[0]); exit(1); } sockid=socket(AF_INET,SOCK_DGRAM,0); if(sockid ==-1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } s.sin_family=AF_INET; s.sin_addr.s_addr=inet_addr(argv[1]); s.sin_port=htons(atoi(argv[2])); printf(\u0026#34;\\nENTER THE REQUEST MESSAGE ::\u0026#34;); scanf(\u0026#34;%s\u0026#34;,m1); slen=sizeof(s); rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr *)\u0026amp;s,slen); if(rval==-1) { perror(\u0026#34;MSG-SEND-ERR:\u0026#34;); exit(1); } printf(\u0026#34;\\nmessage sent sucessfully \\n\u0026#34;); strncpy(m2,\u0026#34; \u0026#34;,20); rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr *)\u0026amp;s,\u0026amp;slen); if(rval==-1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); exit(1); } printf(\u0026#34;\\nmessage received is %s \\n\u0026#34;,m2); close(sockid); }  Program-2d : UDP-TIME #  #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;sys/socket.h\u0026gt;#include\u0026lt;netinet/in.h\u0026gt;#include\u0026lt;sys/types.h\u0026gt;#include\u0026lt;string.h\u0026gt;main(int argc, char * argv[]) { unsigned long timeval,tempval; struct sockaddr_in s; int rval,sockid,slen; char m1[20],m2[100]; system(\u0026#34;clear\u0026#34;); if(argc\u0026lt;3){ printf(\u0026#34;\\nUSAGE :%s IP-Address Port #\\n\u0026#34;, argv[0]); exit(1); } sockid = socket(AF_INET, SOCK_DGRAM,0); if(sockid == -1){ perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } s.sin_family= AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); printf(\u0026#34;\\nSocket created\u0026#34;); slen = sizeof(s); rval = sendto(sockid,m1,sizeof(m1),0,(struct sockaddr *)\u0026amp;s,slen); if(rval == -1){ perror(\u0026#34;\\nMSG-SEND-ERR:\u0026#34;); exit(1); } printf(\u0026#34;\\nMessage sent successfully\\n\u0026#34;); rval = recvfrom(sockid,\u0026amp;tempval,sizeof(tempval),0, (struct sockaddr *)\u0026amp;s,\u0026amp;slen); if(rval == -1){ perror(\u0026#34;MSG-RCV-ERR\u0026#34;); exit(1); } timeval = htonl(tempval); printf(\u0026#34;\\nMessage received is :%u\\n\u0026#34;,timeval); close(sockid); }  Program-4 : UDP-SERVER #  #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;sys/types.h\u0026gt;#include\u0026lt;sys/socket.h\u0026gt;#include\u0026lt;netinet/in.h\u0026gt;#include\u0026lt;string.h\u0026gt;main(int argc,char * argv[]) { int sockid,rval,clen; char buffer[20]; struct sockaddr_in s,c; if(argc\u0026lt;3){ printf(\u0026#34;\\nUSAGE:%s IP_ADDRESS PORT #\\n\u0026#34;,argv[0]); exit(0); } sockid = socket(AF_INET,SOCK_DGRAM,0); if(sockid == -1){ perror(\u0026#34;SOCK-CRE-ERR\u0026#34;); exit(1); } s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); printf(\u0026#34;socket created\\n\u0026#34;); rval = bind(sockid,(struct sockaddr *)\u0026amp;s,sizeof(s)); if(rval == -1){ perror(\u0026#34;BIND-ERR\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;socket binded\\n\u0026#34;); clen = sizeof(c); rval = recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr *)\u0026amp;c,\u0026amp;clen); if(rval == -1){ perror(\u0026#34;MSG-RCV-ERR\u0026#34;); exit(1); } printf(\u0026#34;\\nRequest received\\nRequest message is :%s\\n\u0026#34;,buffer); strcat(buffer,\u0026#34; Juveriya\u0026#34;); rval = sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr *)\u0026amp;c,clen); if(rval == -1){ perror(\u0026#34;MSG-SND-ERR\u0026#34;); exit(1); } printf(\u0026#34;\\nResponse sent successfully\\n\u0026#34;); close(sockid); }  Program-5 : UDP-SERVER-DTS #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;string.h\u0026gt;main(int argc, char *argv[]) { unsigned long timeval, tempval; struct sockaddr_in s; int rval, sockid, slen; char m1[20], m2[20]; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP-Address Port#\\n\u0026#34;, argv[0]); exit(1); } sockid = socket(AF_INET, SOCK_DGRAM, 0); if (sockid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } s.sin_family = AF_INET; s.sin_port = htons(atoi(argv[2])); s.sin_addr.s_addr = inet_addr(argv[1]); printf(\u0026#34;Socket Created\\n\u0026#34;); printf(\u0026#34;\\nEnter the request message : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, m1); slen = sizeof(s); rval = sendto(sockid, m1, sizeof(m1), 0, (struct sockaddr *)\u0026amp;s, slen); if (rval == -1) { perror(\u0026#34;MSG-SEND-ERR:\u0026#34;); exit(1); } printf(\u0026#34;\\nMessage sent successfully\\n\u0026#34;); rval = recvfrom(sockid, \u0026amp;tempval, sizeof(tempval), 0, (struct sockaddr *)\u0026amp;s, \u0026amp;slen); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); exit(1); } timeval = htonl(tempval); printf(\u0026#34;\\nMessage received is : %u\\n\u0026#34;, timeval); close(sockid); }  Program-3a,3b,3c: TCP-CLIENT #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;main(int argc, char *argv[]) { struct sockaddr_in s; int sockid, rval; char m1[20], m2[20]; sockid = socket(AF_INET, SOCK_STREAM, 0); if (sockid == -1) { perror(\u0026#34;SOCK-CRE-ERR\u0026#34;); exit(1); } system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDR PORT#\\n\u0026#34;, argv[0]); exit(0); } s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); rval = connect(sockid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;CONN-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nEnter the request message : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, m1); rval = send(sockid, m1, sizeof(m1), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nMessage sent successfully\\n\u0026#34;); rval = recv(sockid, m2, sizeof(m2), 0); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nServer response is : %s\\n\u0026#34;, m2); close(sockid); }  Program-3d: TCP-TIME #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;main(int argc, char *argv[]) { unsigned long timeval, tempval; int sockid, rval; char m1[20], m2[20]; sockid = socket(AF_INET, SOCK_STREAM, 0); if (sockid == -1) { perror(\u0026#34;SOCK-CRE-ERR\u0026#34;); exit(1); } struct sockaddr_in s; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDR PORT#\\n\u0026#34;, argv[0]); exit(0); } s.sin_family = AF_INET; s.sin_port = htons(atoi(argv[2])); s.sin_addr.s_addr = inet_addr(argv[1]); rval = connect(sockid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;CONN-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nEnter the request message : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, m1); rval = send(sockid, m1, sizeof(m1), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nMessage sent successfully\\n\u0026#34;); rval = recv(sockid, \u0026amp;tempval, sizeof(tempval), 0); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); close(sockid); exit(1); } timeval = htonl(tempval); printf(\u0026#34;\\nServer response is : %u\\n\u0026#34;, timeval); close(sockid); }  Program-6: TCP-SERVER #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;main(int argc, char *argv[]) { int sid, sid1, rval; struct sockaddr_in s, c; char buffer[20]; int clen; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDRESS PORT#\\n\u0026#34;, argv[0]); exit(0); } sid = socket(AF_INET, SOCK_STREAM, 0); if (sid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } /*DEFINING NAME OF THE SERVICE*/ s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); /*BIND SOCKET- indicates the process that is listening*/ rval = bind(sid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;BIND-ERR:\u0026#34;); close(sid); exit(1); } rval = listen(sid, 5); // range : 1-5  if (rval == -1) { perror(\u0026#34;LISTEN-ERR:\u0026#34;); close(sid); exit(1); } clen = sizeof(c); sid1 = accept(sid, (struct sockaddr *)\u0026amp;c, \u0026amp;clen); rval = recv(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); } else { printf(\u0026#34;\\nClient request is %s\\n\u0026#34;, buffer); } rval = send(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); } else { printf(\u0026#34;\\nResponse sent\\n\u0026#34;); } close(sid); close(sid1); }  Program-7: TCP-SERVER-DTS #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026lt;string.h\u0026gt;main(int argc, char *argv[]) { int sid, sid1, rval; time_t t = time(0); struct sockaddr_in s, c; char smsg[30]; strcpy(smsg, ctime(\u0026amp;t)); int clen; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDRESS PORT#\\n\u0026#34;, argv[0]); exit(0); } sid = socket(AF_INET, SOCK_STREAM, 0); if (sid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } /*DEFINING NAME OF THE SERVICE*/ s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); /*BIND SOCKET- indicates the process that is listening*/ rval = bind(sid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;BIND-ERR:\u0026#34;); close(sid); exit(1); } rval = listen(sid, 5); // range : 1-5  if (rval == -1) { perror(\u0026#34;LISTEN-ERR:\u0026#34;); close(sid); exit(1); } clen = sizeof(c); sid1 = accept(sid, (struct sockaddr *)\u0026amp;c, \u0026amp;clen); strcpy(smsg, ctime(\u0026amp;t)); // const time_t* if error  rval = send(sid1, smsg, sizeof(smsg), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); } else { printf(\u0026#34;\\nResponse sent\\n\u0026#34;); } close(sid); close(sid1); }  Program 8: TCP-ITERATIVE SERVER #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;main(int argc, char *argv[]) { int sid, sid1, rval, itr, i; // sid is half association. sid1 is full association  struct sockaddr_in s, c; char buffer[20]; int clen; // accept() uses value-result parameter  system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDRESS PORT#\\n\u0026#34;, argv[0]); exit(0); } printf(\u0026#34;\\nEnter the number of clients to serve/ server iterations : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;itr); sid = socket(AF_INET, SOCK_STREAM, 0); if (sid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } /*DEFINING NAME OF THE SERVICE*/ s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); /*BIND SOCKET- indicates the process that is listening*/ rval = bind(sid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;BIND-ERR:\u0026#34;); close(sid); exit(1); } rval = listen(sid, 5); // range : 1-5  if (rval == -1) { perror(\u0026#34;LISTEN-ERR:\u0026#34;); close(sid); exit(1); } for (i = 1; i \u0026lt;= itr; i++) { clen = sizeof(c); sid1 = accept(sid, (struct sockaddr *)\u0026amp;c, \u0026amp;clen); /*sid1 is a full association tuple and has information of client,server and communication protocol i.e serving socket*/ rval = recv(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); } else { printf(\u0026#34;\\nClient request is %s\\n\u0026#34;, buffer); } rval = send(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); } else { printf(\u0026#34;\\nResponse sent\\n\u0026#34;); } close(sid1); // closing the serving socket  } close(sid); // closing the listening socket }  Program 8: TCP-CONC SERVER #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;main(int argc, char *argv[]) { int sid, sid1, rval, itr, i, pid; // sid is half association. sid1 is full association  struct sockaddr_in s, c; char buffer[20]; int clen; // accept() uses value-result parameter  system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDRESS PORT#\\n\u0026#34;, argv[0]); exit(0); } printf(\u0026#34;\\nEnter the number of clients to serve/ server iterations : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;itr); sid = socket(AF_INET, SOCK_STREAM, 0); if (sid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } /*DEFINING NAME OF THE SERVICE*/ s.sin_family = AF_INET; s.sin_addr.s_addr = inet_addr(argv[1]); s.sin_port = htons(atoi(argv[2])); /*BIND SOCKET- indicates the process that is listening*/ rval = bind(sid, (struct sockaddr *)\u0026amp;s, sizeof(s)); if (rval == -1) { perror(\u0026#34;BIND-ERR:\u0026#34;); close(sid); exit(1); } rval = listen(sid, 5); // range : 1-5  if (rval == -1) { perror(\u0026#34;LISTEN-ERR:\u0026#34;); close(sid); exit(1); } for (i = 1; i \u0026lt;= itr; i++) { clen = sizeof(c); sid1 = accept(sid, (struct sockaddr *)\u0026amp;c, \u0026amp;clen); if (sid1 == -1) { perror(\u0026#34;ACCEPT-ERR:\u0026#34;); close(sid); exit(1); } pid = fork(); if (pid == -1) { perror(\u0026#34;FRK-ERR:\u0026#34;); close(sid1); close(sid); exit(1); } /*sid1 is a full association tuple and has information of client,server and communication protocol i.e serving socket*/ if (pid == 0) // CHILD  { rval = recv(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); } else { printf(\u0026#34;\\nClient request is %s\\n\u0026#34;, buffer); } rval = send(sid1, buffer, sizeof(buffer), 0); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); } else { printf(\u0026#34;\\nResponse sent\\n\u0026#34;); } close(sid1); // closing the serving socket  exit(0); } else // PARENT  close(sid1); /*parent also has a copy of the serving socket. So close it here.*/ } close(sid); // closing the listening socket  exit(0); }  Program 10: DNS #  ==DNS CLIENT==\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;string.h\u0026gt;main(int argc, char *argv[]) { struct sockaddr_in dnss; int sockid, rval; char sym[20], IP[20]; int slen; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDR PORT#\\n\u0026#34;, argv[0]); exit(1); } sockid = socket(AF_INET, SOCK_DGRAM, 0); if (sockid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } dnss.sin_family = AF_INET; dnss.sin_port = htons(atoi(argv[2])); dnss.sin_addr.s_addr = inet_addr(argv[1]); printf(\u0026#34;\\nEnter the symbolic name of resource : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, sym); rval = sendto(sockid, sym, sizeof(sym), 0, (struct sockaddr *)\u0026amp;dnss, sizeof(dnss)); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nWaiting to receive from DNS Server\\n\u0026#34;); slen = sizeof(dnss); strncpy(IP, \u0026#34; \u0026#34;, 20); rval = recvfrom(sockid, IP, sizeof(IP), 0, (struct sockaddr *)\u0026amp;dnss, \u0026amp;slen); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nEquivalent IP adrress of %s is %s\\n\u0026#34;, sym, IP); close(sockid); } ==DNS SERVER==\n/*DNS SERVER PROGRAM*/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;string.h\u0026gt; main(int argc, char *argv[]) { struct sockaddr_in dnss, dnsc; int rval, sockid, flag = 0, clen; char sym[20], IP[20], dnsFile[20], dnsName[20]; FILE *fptr; system(\u0026#34;clear\u0026#34;); if (argc \u0026lt; 3) { printf(\u0026#34;\\nUSAGE : %s IP_ADDR PORT#\\n\u0026#34;, argv[0]); exit(1); } dnss.sin_family = AF_INET; dnss.sin_addr.s_addr = inet_addr(argv[1]); dnss.sin_port = htons(atoi(argv[2])); sockid = socket(AF_INET, SOCK_DGRAM, 0); if (sockid == -1) { perror(\u0026#34;SOCK-CRE-ERR:\u0026#34;); exit(1); } rval = bind(sockid, (struct sockaddr *)\u0026amp;dnss, sizeof(dnss)); if (rval == -1) { perror(\u0026#34;BIND-ERR:\u0026#34;); close(sockid); exit(1); } printf(\u0026#34;\\nDNS Server waiting for request\\n\u0026#34;); printf(\u0026#34;\\nEnter the DNS file name : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, dnsFile); /*OPEN THE FILE*/ fptr = fopen(dnsFile, \u0026#34;r\u0026#34;); if (fptr == NULL) { perror(\u0026#34;FILE-OPEN-ERR:\u0026#34;); close(sockid); exit(1); } clen = sizeof(dnsc); rval = recvfrom(sockid, sym, sizeof(sym), 0, (struct sockaddr *)\u0026amp;dnsc, \u0026amp;clen); if (rval == -1) { perror(\u0026#34;MSG-RCV-ERR:\u0026#34;); close(sockid); fclose(fptr); exit(1); } printf(\u0026#34;\\nIP requested for %s\\n\u0026#34;, sym); while ((fscanf(fptr, \u0026#34;%s%s\u0026#34;, dnsName, IP) != EOF)) { if (strcmp(dnsName, sym) == 0) { rval = sendto(sockid, IP, sizeof(IP), 0, (struct sockaddr *)\u0026amp;dnsc, clen); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); fclose(fptr); close(sockid); exit(1); } flag = 1; } printf(\u0026#34;\\nflag value in loop is %d\\n\u0026#34;, flag); if (flag == 1) // INDICATES THAT MATCH IS FOUND  break; } if (flag == 0) { printf(\u0026#34;\\ninvalid domain name case\\n\u0026#34;); rval = sendto(sockid, \u0026#34;NOT FOUND\u0026#34;, sizeof(\u0026#34;NOT FOUND\u0026#34;), 0, (struct sockaddr *)\u0026amp;dnsc, clen); if (rval == -1) { perror(\u0026#34;MSG-SND-ERR:\u0026#34;); fclose(fptr); close(sockid); exit(1); } } fclose(fptr); close(sockid); } ","date":"10 November 2023","permalink":"/cn-chapter/cn-lab/","section":"CN-chapters","summary":"Click test-gpt to view detailed explanation of below programs.","title":"CN LAB"},{"content":"","date":"10 November 2023","permalink":"/cn-chapter/","section":"CN-chapters","summary":"","title":"CN-chapters"},{"content":"    Alternatively you can also visit   Data Communication Components #   Representation of Data Communication #    Data communication involves the exchange of information between two or more devices using a communication medium.\n  Components include:\n  Message: The information or data being communicated.\n  Sender: Initiates the communication by creating and sending the message.\n  Receiver: Receives and interprets the message sent by the sender.\n  Transmission Medium: The physical path through which the message travels.\n     Flow of Networks #   The flow of networks refers to the intricate process of data transfer between devices in a network.    Data Generation:\n The process begins with the generation of data by a device. This data could be in various forms such as text, images, audio, or video.    Data Encoding and Formatting:\n Before transmission, the data is encoded into a format suitable for transmission. Formatting includes adding necessary headers, footers, or error-checking codes.    Data Transmission:\n The formatted data is then transmitted from the sender to the receiver over the communication medium. This involves the conversion of digital data into analog signals for transmission over analog channels.    Signal Propagation:\n The signals travel through the transmission medium. This could be physical cables, optical fibers, or wireless channels.    Routing:\n In the network, the process of determining the most efficient path for data to travel is called routing. Routers play a crucial role in forwarding data between different networks.    Signal Reception:\n The receiving device captures the transmitted signals. In the case of wireless communication, this involves the reception of radio waves or microwaves.    Signal Decoding:\n The received signals are decoded to retrieve the original digital data. Decoding involves reversing the encoding and formatting applied at the sender\u0026rsquo;s end.    Error Detection and Correction:\n The received data may undergo error detection and correction processes. Techniques like parity checks or checksums are employed to ensure data integrity.    Error Handling:\n If errors are detected, various error-handling mechanisms come into play. This may involve retransmission of data, requesting missing pieces, or applying error correction algorithms.    Response Handling:\n Once the data is successfully received and decoded, the receiving device generates a response. The response may confirm successful data reception or indicate an issue that needs attention.    Data Decryption (if encrypted):\n If the data was encrypted during transmission, the receiving device decrypts it using the appropriate decryption key.    Data Interpretation:\n The final step involves interpreting the received data, making it meaningful for the receiving device or application.    Security Considerations:\n Throughout the entire process, security measures are implemented to protect data from unauthorized access, interception, or tampering. This may involve encryption, secure protocols, and authentication mechanisms.     Layered Architecture #   OSI Model #    The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes the functions of a telecommunication or computing system into seven abstraction layers.\n  Layers of the OSI model:\n  Physical Layer: Deals with the physical connection and transmission of raw bits over a physical medium.\n  Data Link Layer: Responsible for creating a reliable link between two directly connected nodes, providing error detection and correction.\n  Network Layer: Manages the routing and forwarding of data packets between devices across different networks.\n  Transport Layer: Ensures end-to-end communication, including error recovery and flow control.\n  Session Layer: Manages sessions or connections between applications on different devices.\n  Presentation Layer: Handles data format translation, encryption, and compression.\n  Application Layer: Provides network services directly to end-users or applications.\n     TCP/IP Model #    The TCP/IP (Transmission Control Protocol/Internet Protocol) model is the foundation of the Internet.\n  Layers of the TCP/IP model:\n  Link Layer (equivalent to OSI\u0026rsquo;s Data Link and Physical layers): Deals with the physical and data link aspects of network communication.\n  Internet Layer (equivalent to OSI\u0026rsquo;s Network Layer): Manages the routing and addressing of data packets across interconnected networks.\n  Transport Layer (equivalent to OSI\u0026rsquo;s Transport Layer): Ensures reliable end-to-end communication by handling data segmentation, flow control, and error recovery.\n  Application Layer (encompasses OSI\u0026rsquo;s Session, Presentation, and Application layers): Provides network services directly to end-users or applications.\n     Transmission Media #    Transmission Media refers to the physical pathways that transmit data in a network.\n  Types of transmission media:\n  Guided Media (Wired):\n Twisted Pair: Two insulated copper wires twisted together. Coaxial Cable: A central conductor surrounded by an insulating layer and a metallic shield. Fiber Optic Cable: Transmits data as light pulses through glass or plastic fibers.    Unguided Media (Wireless):\n Radio Waves: Wireless communication using radio frequency. Microwaves: High-frequency electromagnetic waves for long-distance communication. Infrared Waves: Short-range communication using infrared light.       Techniques for Bandwidth Utilization #   Line Configuration #    Line Configuration refers to the way two or more devices are connected in a communication channel.\n  Types of line configuration:\n  Point-to-Point: A direct link between two devices.\n  Multipoint (or Multidrop): Multiple devices share the same communication channel.\n     Multiplexing #   Frequency Division Multiplexing (FDM) #    FDM divides the frequency band of the channel into smaller sub-bands, with each sub-band dedicated to a different communication channel.\n  FDM is commonly used in radio and television broadcasting.\n   Time Division Multiplexing (TDM) #    TDM divides the time into fixed intervals, and each interval is allocated to different communication channels in a round-robin fashion.\n  TDM is widely used in digital communication systems.\n   Wave Division Multiplexing (WDM) #    WDM uses different wavelengths (colors) of light to transmit data simultaneously over optical fibers.\n  It is extensively used in high-capacity fiber-optic communication systems.\n   Asynchronous and Synchronous Transmission #    Asynchronous Transmission:\n Data is sent without a shared clock signal. Start and stop bits frame each character for synchronization.    Synchronous Transmission:\n Data is sent in blocks or frames with synchronization achieved through a shared clock signal. More efficient than asynchronous transmission for large amounts of data.     XDSL #    XDSL (Digital Subscriber Line) refers to a family of technologies that provide digital data transmission over the local telephone line.\n  Types of XDSL include ADSL (Asymmetric DSL), SDSL (\n  Symmetric DSL), and VDSL (Very High Bitrate DSL).\n Introduction to Wired and Wireless LAN #   Local Area Network (LAN):   A network that covers a small geographic area, like a single building or a campus.\n  Wired LAN: Uses physical cables (e.g., Ethernet) for communication.\n  Wireless LAN (WLAN):\n  Utilizes wireless communication technologies such as Wi-Fi.\n  Offers flexibility and mobility, allowing devices to connect without physical cables.\n      ","date":"9 November 2023","permalink":"/cn-chapter/cn-chapter-1/","section":"CN-chapters","summary":"Alternatively you can also visit   Data Communication Components #   Representation of Data Communication #    Data communication involves the exchange of information between two or more devices using a communication medium.","title":"CN chapter-1"},{"content":"  document.addEventListener(\"DOMContentLoaded\", function () { new TypeIt(\"#typeit-0-1707159623077194308\", { strings: [\"\",\"UseCase Diagrams:\",\"\"], speed: 100 , lifeLike: true , startDelay: 0 , breakLines: true , waitUntilVisible: true , loop: false }).go(); });     click image to zoom in  --   $(window).on(\"load\", function () { $('#gallery-2-1707159623077447850').packery({ percentPosition: true, gutter: 5, resize: true }); })     document.addEventListener(\"DOMContentLoaded\", function () { new TypeIt(\"#typeit-3-1707159623077494808\", { strings: [\"\",\"Class Diagrams:\",\"\"], speed: 100 , lifeLike: true , startDelay: 0 , breakLines: true , waitUntilVisible: true , loop: false }).go(); });  --   $(window).on(\"load\", function () { $('#gallery-4-1707159623077523255').packery({ percentPosition: true, gutter: 5, resize: true }); })   ## (THEORY WEEK-1)   document.addEventListener(\"DOMContentLoaded\", function () { new TypeIt(\"#typeit-5-1707159623077560561\", { strings: [\"\",\"Unified Modeling Language (UML)\",\"\",\"\"], speed: 100 , lifeLike: false , startDelay: 0 , breakLines: true , waitUntilVisible: true , loop: false }).go(); });     document.addEventListener(\"DOMContentLoaded\", function () { new TypeIt(\"#typeit-6-1707159623077610001\", { strings: [\"\",\"Sequence and Collab diagrams\",\"\",\"\"], speed: 100 , lifeLike: false , startDelay: 0 , breakLines: true , waitUntilVisible: true , loop: false }).go(); });  --   $(window).on(\"load\", function () { $('#gallery-7-1707159623077632236').packery({ percentPosition: true, gutter: 5, resize: true }); }) \n 1. Introduction to UML #  Unified Modeling Language (UML) is a comprehensive language used for visualizing, specifying, constructing, and documenting software systems. It provides a standardized approach to system design, allowing software professionals to communicate and understand complex concepts through visual representations.\n 2. Basic Building Blocks in UML #  UML encompasses three fundamental building blocks: things, relationships, and diagrams. These components are essential for creating a comprehensive model of a software system.\n 2.1 Things in UML #  UML defines various types of things that represent both the static and dynamic aspects of a system:\n  Class: Represents a template for creating objects, encapsulating attributes and behaviors.\n  Object: An instance of a class, representing a real-world entity in the system.\n  Interface: Describes a set of methods that a class or component must implement.\n  Use Case: Represents a specific functionality or behavior of a system from an external perspective.\n   2.2 Relationships in UML #  UML allows the modeling of relationships between different elements, contributing to the overall structure of the system:\n  Association: Describes a bi-directional relationship between two classes.\n  Aggregation: Represents a \u0026ldquo;whole-part\u0026rdquo; relationship, where a whole is composed of parts.\n  Composition: Denotes a strong form of aggregation, where the part is a component of the whole and cannot exist independently.\n  Inheritance: Illustrates an \u0026ldquo;is-a\u0026rdquo; relationship between a superclass and its subclasses.\n   3. Types of Things in UML #   3.1 Structural Things #  Structural things in UML focus on the static aspects of a system. Key types include classes, objects, and interfaces. ![[Pasted image 20231130143054.png]]\n 3.2 Behavioral Things #  Behavioral things in UML represent dynamic aspects, such as use cases and collaborations. Use cases define the functionality the system should provide.\n 4. Types of Relationships in UML #   4.1 Dependency #  Denotes a relationship where a change in one thing may affect another.\n 4.2 Association #  Represents a connection between two classes, often denoting a bi-directional relationship.\n 4.3 Generalization #  Illustrates an \u0026ldquo;is-a\u0026rdquo; relationship, typically associated with inheritance.\n 4.4 Realization #  Shows how a class implements an interface.\n 5. Use Case Diagrams in Detail #  Use case diagrams in UML focus on the functional requirements of a system. They include:\n  Actor: Represents an external entity interacting with the system.\n  Use Case: Describes a specific functionality or action the system can perform.\n  Relationships: Connect actors and use cases, illustrating how external entities interact with the system.\n  Use case diagrams provide a high-level view of system functionality, aiding in understanding user interactions and system behavior.\n","date":"6 November 2023","permalink":"/se-chapter/se-lab/","section":"SE-chapters","summary":"document.","title":"SE LAB"},{"content":"","date":"6 November 2023","permalink":"/se-chapter/","section":"SE-chapters","summary":"","title":"SE-chapters"},{"content":" Things to Do After Installing a Debian-Based Distro #  Congratulations on installing your Debian-based Linux distribution! To make the most of your new operating system, here is a list of essential tasks to complete and things to consider after the installation.\n Update and Upgrade Your System #  Before you start customizing your system, it\u0026rsquo;s crucial to ensure your installation is up to date:\nOpen a terminal and run the following commands:\nsudo apt update sudo apt upgrade This will update your package list and upgrade all installed packages to their latest versions.\n Install Additional Software #    Package Management: Debian-based systems use APT (Advanced Package Tool) for package management. You can install software using the apt command. For example:\n To install a web browser (e.g., Firefox): sudo apt install firefox To install an office suite (e.g., LibreOffice): sudo apt install libreoffice    Software Center: Many Debian-based distributions come with a software center where you can easily browse and install software using a graphical interface.\n  Snap and Flatpak: Consider enabling Snap or Flatpak for access to additional software not available in the official repositories. You may need to install the Snap or Flatpak runtime.\n Snap: sudo apt install snapd Flatpak: Check your distribution\u0026rsquo;s documentation for installation instructions.     Configure System Repositories #  Ensure that your system is configured to access the appropriate repositories, including security updates and third-party sources if needed. Edit the /etc/apt/sources.list file or use a software source management tool, like software-properties-gtk (for Debian/Ubuntu systems).\nsudo software-properties-gtk  Install Proprietary Drivers #  If your system requires proprietary drivers for optimal hardware support, install them via the \u0026ldquo;Additional Drivers\u0026rdquo; utility or through the terminal. This may be necessary for graphics cards, Wi-Fi adapters, and more.\n Set Up User Accounts and Passwords #  Create additional user accounts for better security and isolation. To add a new user:\nsudo adduser newusername Make sure to add your user to the sudo group for administrative privileges:\nsudo usermod -aG sudo newusername Change passwords for the root user and your user account:\nsudo passwd root passwd yourusername  System Tweaks and Customization #    Desktop Environment: Customize your desktop environment according to your preferences. This may include changing wallpapers, themes, and settings.\n  Keyboard Shortcuts: Configure keyboard shortcuts for efficiency.\n  Display Settings: Adjust screen resolution, multiple monitor setup, and screen brightness.\n  Software Updates: Set up automatic software updates for security and system stability.\n  Firewall: Enable and configure the firewall (e.g., ufw or iptables) to enhance system security.\n  Time and Date: Set your time zone and synchronize your system clock with network time servers.\n  User Directories: Configure user directories, such as Downloads, Documents, and Pictures, for better organization.\n   Install Essential Software #  Install common Linux tools and utilities, including:\n Text editor (e.g., Vim or Nano) File manager (e.g., Nautilus, Dolphin) Terminal emulator (e.g., GNOME Terminal, Konsole) Archiving tool (e.g., File Roller, Ark) PDF reader (e.g., Evince, Okular) Image viewer (e.g., Eye of GNOME, Gwenview)   Optimize Power Saving for Wi-Fi #  To improve Wi-Fi speed and responsiveness, you can tweak power-saving settings:\n  Disable Wi-Fi Power Saving Mode: By default, Wi-Fi adapters often use power-saving features, which can reduce performance. To disable it temporarily (until the next reboot):\nsudo iwconfig wlan0 power off Replace wlan0 with the name of your Wi-Fi interface.\nTo disable it permanently, you can create a configuration file. Create a file in the /etc/network/if-up.d/ directory, such as /etc/network/if-up.d/wifi-power-off, with the following content:\n#!/bin/sh /sbin/iwconfig wlan0 power off Make it executable with:\nsudo chmod +x /etc/network/if-up.d/wifi-power-off   Tune Network Manager: If you are using NetworkManager, you can edit its configuration to control power management. Open the NetworkManager configuration file:\nsudo nano /etc/NetworkManager/conf.d/default-wifi-powersave-on.conf Change the value from 3 to 2 to disable Wi-Fi power-saving:\n[connection] wifi.powersave = 2 Save the file and restart NetworkManager:\nsudo service network-manager restart    Improve Security #    Firewall: Configure and enable a firewall (e.g., Uncomplicated Firewall, UFW) to control incoming and outgoing traffic.\n  Full Disk Encryption: If it\u0026rsquo;s not already enabled, consider setting up full-disk encryption (e.g., LUKS) to protect your data in case your device gets stolen.\n  ","date":"5 November 2023","permalink":"/posts/linux-setup/","section":"Posts","summary":"Things to Do After Installing a Debian-Based Distro #  Congratulations on installing your Debian-based Linux distribution!","title":"Debian based linux distro Setup"},{"content":"","date":"5 November 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" Problem Solving \u0026amp; Search #   Introduction to Intelligence #    Artificial Intelligence (AI) is a multidisciplinary field that seeks to create intelligent agents capable of emulating human-like behaviors such as problem-solving, learning, understanding natural language, and interacting with the environment.\n  AI encompasses a wide range of techniques and methodologies for building intelligent systems.\n   Foundations of Artificial Intelligence #    AI draws on several foundational components:\n  Machine Learning: Algorithms and models that enable machines to learn from data and improve their performance over time.\n  Knowledge Representation: Methods for storing, organizing, and reasoning with information in a way that machines can utilize.\n  Problem Solving: Developing algorithms to find solutions to complex problems.\n  Natural Language Processing (NLP): Techniques for understanding and generating human language.\n  Computer Vision: Enabling machines to interpret visual information from images or videos.\n    AI systems often combine these foundational elements to achieve intelligent behavior.\n   History of AI #   The history of AI can be divided into several key phases:   Early Foundations (1950s-1960s): The term \u0026ldquo;artificial intelligence\u0026rdquo; was first coined, and early AI programs were developed. This period was marked by optimism and high expectations.\n  AI Winter (1970s-1980s): Funding and interest in AI waned due to unrealistic expectations, limited computational power, and modest progress. Research slowed during this period.\n  Resurgence (late 20th century): Advances in machine learning, expert systems, and neural networks reignited interest in AI.\n  Contemporary AI (21st century): Recent progress in deep learning, reinforcement learning, and the availability of vast amounts of data have propelled AI into diverse applications, including self-driving cars, natural language processing, and more.\n     Structure of Agents #    In the context of AI, an agent is a system that perceives its environment through sensors and takes actions using actuators. Agents can range from simple to complex.\n  Key components of an agent include:\n  Sensors: These devices collect information from the environment. Sensors can include cameras, microphones, or other sensors specific to the agent\u0026rsquo;s function.\n  Actuators: These mechanisms execute actions in the environment, such as moving a robot\u0026rsquo;s wheels or generating text on a screen.\n  Knowledge Base: An internal storage system that retains information and knowledge necessary for decision-making.\n  Inference Engine: The component of the agent responsible for reasoning and making decisions based on the knowledge it possesses.\n     Problem Solving #   Formulating Problems #    In AI, problem-solving involves finding a sequence of actions that transforms an initial state into a goal state. This process is vital for tasks like planning and decision-making.\n  Problems are typically formulated with three main components:\n  Initial State: The starting configuration or situation.\n  Goal State: The desired outcome or target configuration.\n  Operators: Actions that can be applied to states, leading to state transitions.\n    The solution to a problem is a sequence of operators that, when applied to the initial state, results in the goal state.\n   Problem Types #   Problems in AI can be categorized based on various characteristics:   Deterministic: Problems where outcomes are entirely predictable and free from randomness. Chess is a deterministic game.\n  Nondeterministic: Problems with an element of randomness or uncertainty. Card games involve nondeterministic elements.\n  Sequential: Problems where the order of decisions and actions significantly impacts future states. Chess is an example of a sequential game.\n  Adversarial: Competitive problems where two or more agents have conflicting goals. Games like chess and tic-tac-toe are adversarial problems.\n     States and Operators #    In problem-solving, a state represents a particular configuration or situation within the problem space. It is a snapshot of the problem at a specific point in time.\n  Operators are actions that can be applied to states, leading to state transitions. These operators define the legal moves or transformations in the problem space.\n  For instance, in the 8-Puzzle problem, states are different configurations of the puzzle board, and operators are the actions of moving a tile to an adjacent empty space.\n   State Space #    The state space of a problem comprises all possible states that can be reached from the initial state by applying operators. It represents the entire landscape of the problem.\n  State spaces can vary in size and complexity. For some problems, exploring the entire state space may be computationally infeasible.\n   Search Strategies #   Search strategies are algorithms used to explore the state space and find solutions to problems. Common search strategies include:   Breadth-First Search (BFS): BFS explores all neighbors of a state before moving deeper into the state space. It is guaranteed to find the shortest path to the goal if the state space is finite and unweighted.\n  Depth-First Search (DFS): DFS explores as far as possible along one branch of the state space tree before backtracking. It is often used when memory is limited, and it may not necessarily find the shortest path.\n  Uniform Cost Search: This strategy expands nodes with the lowest path cost, making it suitable for problems where different operators have different costs.\n     Breadth-First Search (BFS) Algorithm #  Breadth-First Search explores the state space level by level, expanding all nodes at a given level before moving to the next level. It is implemented using a queue data structure.\n# Pseudocode for Breadth-First Search function BFS(initial_state, goal_state): initialize an empty queue enqueue initial_state while the queue is not empty: current_state = dequeue from the queue if current_state is the goal_state: return solution path for each successor_state of current_state: if successor_state has not been visited: enqueue successor_state mark successor_state as visited return no solution found  Depth-First Search (DFS) Algorithm #  Depth-First Search explores the state space by traversing as deeply as possible along a branch before backtracking. It is implemented using a stack or recursion.\n# Pseudocode for Depth-First Search function DFS(current_state, goal_state): if current_state is the goal_state: return solution path for each successor_state of current_state: if successor_state has not been visited: result = DFS(successor_state, goal_state) if result is a solution path: return result return no solution found  Informed Search Strategies #    Informed search strategies use domain-specific knowledge to guide the search more efficiently. These strategies are especially valuable when the state space is large.\n  Best-First Search: This algorithm selects the node that is closest to the goal state based on an evaluation function. The evaluation function is typically a heuristic that estimates the cost from the current state to the goal.\n  A Algorithm*: A* combines the cost of the path from the initial state with a heuristic that estimates the cost\n  from the current state to the goal. It uses the sum of these two values to guide the search. A* is optimal and complete if the heuristic is admissible and consistent.\n Heuristic Functions #    A heuristic function provides an estimate of the cost from a given state to the goal state. It is crucial for informed search algorithms such as A*.\n  A heuristic function should have two essential properties:\n  Admissibility: It should never overestimate the true cost to reach the goal from the current state. If a heuristic is admissible, A* is guaranteed to find the optimal solution.\n  Consistency: The heuristic should satisfy the triangle inequality, ensuring that it provides meaningful guidance during the search.\n    Example of a heuristic for the 8-Puzzle problem: The number of misplaced tiles is a simple heuristic. It counts the number of tiles in the current state that are not in their correct positions. This heuristic is admissible but not always consistent.\n  # Example Heuristic for 8-Puzzle: Number of misplaced tiles def heuristic(state, goal): count = 0 for i in range(len(state)): if state[i] != goal[i]: count += 1 return count  Iterative Deepening A* (IDA*) #    Iterative Deepening A* (IDA*) is an advanced search algorithm that combines the principles of A* with depth-first search. It is often used when memory is limited, but a near-optimal solution is required.\n  The algorithm starts with a shallow depth limit and gradually increases it with each iteration until it finds a solution.\n  IDA* uses the A* heuristic and is designed to find the optimal solution when a consistent heuristic is used.\n   Adversarial Search/Game Playing #   Perfect Decision Game #    In a perfect decision game, both players have complete knowledge of the game and can see the entire game tree. They make optimal decisions to maximize their chances of winning.\n  The classic algorithm for perfect information games is the Minimax Algorithm.\n   Minimax Algorithm #    The Minimax Algorithm is a decision-making algorithm used in perfect decision games like chess and tic-tac-toe.\n  It operates on the principle of minimizing the possible loss for a worst-case scenario. In the context of game playing, it means that each player assumes that their opponent makes optimal moves to maximize their own outcome.\n  The algorithm is based on a tree structure, with nodes representing game states and edges representing possible moves.\n  # Pseudocode for Minimax Algorithm function minimax(node, depth, maximizingPlayer): if depth is 0 or node is a terminal node: return the heuristic value of node if maximizingPlayer: bestValue = -âˆž for child in node\u0026#39;s children: value = minimax(child, depth - 1, False) bestValue = max(bestValue, value) return bestValue else: bestValue = +âˆž for child in node\u0026#39;s children: value = minimax(child, depth - 1, True) bestValue = min(bestValue, value) return bestValue  Imperfect Decision Game #    In an imperfect decision game, not all information is available to the players. There may be hidden information, uncertainty, or randomness involved.\n  Alpha-Beta Pruning is a critical optimization technique to improve the efficiency of the Minimax Algorithm in these games.\n   Alpha-Beta Pruning #    Alpha-Beta Pruning is a search algorithm enhancement that reduces the number of nodes evaluated in the Minimax Algorithm.\n  It uses two values, alpha and beta, to keep track of the best values found so far for the maximizing and minimizing players, respectively.\n  Alpha represents the best value found for the maximizing player, and beta represents the best value for the minimizing player.\n  The algorithm prunes branches of the search tree that cannot lead to better results. If alpha becomes greater than or equal to beta, a branch can be safely pruned.\n  # Pseudocode for Alpha-Beta Pruning function alpha_beta(node, depth, alpha, beta, maximizingPlayer): if depth is 0 or node is a terminal node: return the heuristic value of node if maximizingPlayer: for child in node\u0026#39;s children: alpha = max(alpha, alpha_beta(child, depth - 1, alpha, beta, False)) if beta â‰¤ alpha: break return alpha else: for child in node\u0026#39;s children: beta = min(beta, alpha_beta(child, depth - 1, alpha, beta, True)) if beta â‰¤ alpha: break return beta ","date":"5 November 2023","permalink":"/ai-chapter/ai-chapter-1/","section":"AI-chapters","summary":"Problem Solving \u0026amp; Search #   Introduction to Intelligence #    Artificial Intelligence (AI) is a multidisciplinary field that seeks to create intelligent agents capable of emulating human-like behaviors such as problem-solving, learning, understanding natural language, and interacting with the environment.","title":"AI chapter-1"},{"content":" AI lab #   Week-1(from list) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week1_listset.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; list=[1,2,\u0026#34;Quadeer\u0026#34;,4,5] print(list) list1=[1,2,3,4] list2=list1+[\u0026#34;programming\u0026#34;] print(list2) list1.insert(2 ,9) print(list1) list1=[1,2,3] list1.append(678) print(list1) list1=[1,2,3] list1.extend([65,99.7]) print(list1) list=[1,2,3,4,\u0026#34;python\u0026#34;] list[4]=\u0026#34;Quadeer\u0026#34; print(list) del(list[2]) print(list) list=[7,3,9,1,8] list.sort() print(list) list.reverse() print(list) print(len(list)) print(sum(list)) print(min(list)) print(max(list)) print(9 in list) #tuples tup=(1,4,7,8) print(tup) tup=(\u0026#34;Quadeer\u0026#34;,4,5,6) print(tup) tup=(\u0026#34;Quadeer\u0026#34;,4,5,6) tup_new=tup+(\u0026#34;ash\u0026#34;,17) print(tup_new) print(tup[0]) print(tup[1]) x=(1,(\u0026#34;Quadeer\u0026#34;,\u0026#34;ash\u0026#34;)) print(x[1][1]) print(x[0]) x=(1,(\u0026#34;Quadeer\u0026#34;,\u0026#34;ash\u0026#34;),(\u0026#34;python\u0026#34;,\u0026#34;master\u0026#34;)) print(x[2,1]) print(x[2][1]) print(x[2][0]) #nested list x=[1, (\u0026#34;Quadeer\u0026#34;),(\u0026#34;ash\u0026#34;)] print(x[1][1]) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:1000,\u0026#34;india\u0026#34;:2220} print(d) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;Quadeer\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;ash\u0026#34;)} print(d) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;Quadeer\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;ash\u0026#34;)} print(d[\u0026#34;uk\u0026#34;]) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;Quadeer\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;ash\u0026#34;)} del(d[\u0026#34;usa\u0026#34;]) print(d) #sets set={\u0026#39;Quadeer\u0026#39;,\u0026#39;ash\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;} print(set) set={\u0026#39;Quadeer\u0026#39;,\u0026#39;ash\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;,\u0026#39;ash\u0026#39;} print(set) set={\u0026#39;Quadeer\u0026#39;,\u0026#39;ash\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;} print(set.add(\u0026#39;add\u0026#39;)) set.add(\u0026#39;add\u0026#39;) print(set) set.remove(\u0026#39;add\u0026#39;) print(set) print(len(set)) s1={1,2,4,5,6} s2={1,2,3,7,9} print(s1\u0026amp;s2) print(s1.intersection(s2)) print(s1|s2) print(s1.union(s2)) def my_add(a): b=a+2 return b print(my_add(4))  Week-2 (basics + BFS) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week2bfs_s_q.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; stack=[] stack.append(\u0026#39;a\u0026#39;) stack.append(\u0026#39;b\u0026#39;) stack.append(\u0026#39;c\u0026#39;) print(stack) print(stack.pop()) print(stack.pop()) print(stack) print(stack.pop()) print(stack.pop()) print(stack.pop()) queue=[] print() queue.append(\u0026#39;a\u0026#39;) queue.append(\u0026#39;b\u0026#39;) queue.append(\u0026#39;c\u0026#39;) print(\u0026#34;initial queue\u0026#34;) print(queue) print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) from queue import PrioriyQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) print(q.get()) print(q) print(q.get()) from queue import PriorityQueue q=PriorityQueue q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) from queue import PriorityQueue q=PriorityQueue q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.get()) from queue import PriorityQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.get()) print(q.get()) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.empty()) print(q.full()) print(q.qsize()) print(q.get()) from queue import PriorityQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) # Commented out IPython magic to ensure Python compatibility. #tree # %pip install treelib from treelib import Tree tree = Tree() tree.create_node(\u0026#39;Quadeer\u0026#39;,\u0026#39;Quadeer\u0026#39;)#root node tree.create_node(\u0026#39;jane\u0026#39;,\u0026#39;Jane\u0026#39;,parent=\u0026#39;Quadeer\u0026#39;) tree.show() print(tree) from treelib import Tree tree=Tree() tree.create_node(1,\u0026#39;Quadeer\u0026#39;) tree.create_node(2,2,parent=\u0026#39;Quadeer\u0026#39;) tree.create_node(3,3,parent=\u0026#39;Quadeer\u0026#39;) tree.create_node(4,4,parent=2) tree.create_node(5,5,parent=3) tree.show() print(tree) #bfs graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } def bfs(graph,initial): visited=[] queue=[initial] while queue: node=queue.pop(0) if node not in visited: visited.append(node) neighbours = graph[node] for neighbour in neighbours: queue.append(neighbour) return visited print(bfs(graph,\u0026#39;3\u0026#39;)) #bfs undirected graph graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;2\u0026#39;:[\u0026#39;3\u0026#39;], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;,\u0026#39;3\u0026#39;], \u0026#39;8\u0026#39;:[\u0026#39;7\u0026#39;] } def bfs(graph,initial): visited=[] queue=[initial] while queue: node=queue.pop(0) if node not in visited: visited.append(node) neighbours = graph[node] for neighbour in neighbours: queue.append(neighbour) return visited print(bfs(graph,\u0026#39;3\u0026#39;))  Week-3 (DFS and Best-fit-search) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Untitled10.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } visited = set() # to keep track of nodes def dfs(visited,graph,node): if node not in visited: print(node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour) #driver code print(\u0026#34;dfs\u0026#34;) dfs(visited,graph,\u0026#39;5\u0026#39;) graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } visited = set() # to keep track of nodes def dfs(visited,graph,node): if node not in visited: print(node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour) #driver code print(\u0026#34;dfs\u0026#34;) dfs(visited,graph,\u0026#39;3\u0026#39;) from queue import PriorityQueue v = 14 graph = [[] for i in range(v)] # Function For Implementing Best First Search # Gives output path having lowest cost def best_first_search(actual_Src, target, n): visited = [False] * n pq = PriorityQueue() pq.put((0, actual_Src)) visited[actual_Src] = True while pq.empty() == False: u = pq.get()[1] # Displaying the path having lowest cost print(u, end=\u0026#34; \u0026#34;) if u == target: break for v, c in graph[u]: if visited[v] == False: visited[v] = True pq.put((c, v)) print() # Function for adding edges to graph def addedge(x, y, cost): graph[x].append((y, cost)) graph[y].append((x, cost)) # The nodes shown in above example(by alphabets) are # implemented using integers addedge(x,y,cost); addedge(0, 1, 3) addedge(0, 2, 6) addedge(0, 3, 5) addedge(1, 4, 9) addedge(1, 5, 8) addedge(2, 6, 12) addedge(2, 7, 14) addedge(3, 8, 7) addedge(8, 9, 5) addedge(8, 10, 6) addedge(9, 11, 1) addedge(9, 12, 10) addedge(9, 13, 2) source = 0 target = 9 best_first_search(source, target, v)  Week-4 (a* algo) #  def aStarAlgo(start_node, stop_node): open_set = set(start_node) closed_set = set() g = {} #store distance from starting node parents = {} # parents contains an adjacency map of all nodes #distance of starting node from itself is zero g[start_node] = 0 #start_node is root node i.e it has no parent nodes #so start_node is set to its own parent node parents[start_node] = start_node while len(open_set) \u0026gt; 0: n = None #node with lowest f() is found for v in open_set: if n == None or g[v] + heuristic(v) \u0026lt; g[n] + heuristic(n): n = v if n == stop_node or Graph_nodes[n] == None: pass else: for (m, weight) in get_neighbors(n): #nodes \u0026#39;m\u0026#39; not in first and last set are added to first #n is set its parent if m not in open_set and m not in closed_set: open_set.add(m) parents[m] = n g[m] = g[n] + weight #for each node m,compare its distance from start i.e g(m) to the #from start through n node else: if g[m] \u0026gt; g[n] + weight: #update g(m) g[m] = g[n] + weight #change parent of m to n parents[m] = n #if m in closed set,remove and add to open if m in closed_set: closed_set.remove(m) open_set.add(m) if n == None: print(\u0026#39;Path does not exist!\u0026#39;) return None # if the current node is the stop_node # then we begin reconstructin the path from it to the start_node if n == stop_node: path = [] while parents[n] != n: path.append(n) n = parents[n] path.append(start_node) path.reverse() print(\u0026#39;Path found: {}\u0026#39;.format(path)) return path # remove n from the open_list, and add it to closed_list # because all of his neighbors were inspected open_set.remove(n) closed_set.add(n) print(\u0026#39;Path does not exist!\u0026#39;) return None #define fuction to return neighbor and its distance #from the passed node def get_neighbors(v): if v in Graph_nodes: return Graph_nodes[v] else: return None #for simplicity we ll consider heuristic distances given #and this function returns heuristic distance for all nodes def heuristic(n): H_dist = { \u0026#39;A\u0026#39;: 11, \u0026#39;B\u0026#39;: 6, \u0026#39;C\u0026#39;: 99, \u0026#39;D\u0026#39;: 1, \u0026#39;E\u0026#39;: 7, \u0026#39;G\u0026#39;: 0, } return H_dist[n] #Describe your graph here Graph_nodes = { \u0026#39;A\u0026#39;: [(\u0026#39;B\u0026#39;, 2), (\u0026#39;E\u0026#39;, 3)], \u0026#39;B\u0026#39;: [(\u0026#39;A\u0026#39;, 2), (\u0026#39;C\u0026#39;, 1), (\u0026#39;G\u0026#39;, 9)], \u0026#39;C\u0026#39;: [(\u0026#39;B\u0026#39;, 1)], \u0026#39;D\u0026#39;: [(\u0026#39;E\u0026#39;, 6), (\u0026#39;G\u0026#39;, 1)], \u0026#39;E\u0026#39;: [(\u0026#39;A\u0026#39;, 3), (\u0026#39;D\u0026#39;, 6)], \u0026#39;G\u0026#39;: [(\u0026#39;B\u0026#39;, 9), (\u0026#39;D\u0026#39;, 1)] } aStarAlgo(\u0026#39;A\u0026#39;, \u0026#39;G\u0026#39;)  Week-5 (BFS-greedy and prolog) #  # bfs-greedy from queue import PriorityQueue v = 14 graph = [[] for i in range(v)] # Function For Implementing Greedy Best First Search # Gives output path having lowest cost def greedy_best_first_search(actual_Src, target, n): visited = [False] * n pq = PriorityQueue() pq.put((0, actual_Src)) visited[actual_Src] = True while pq.empty() == False: u = pq.get()[1] # Displaying the path having lowest cost print(u, end=\u0026#34; \u0026#34;) if u == target: break for v, c in graph[u]: if visited[v] == False: visited[v] = True pq.put((c, v)) print() # Function for adding edges to graph def add_edge(x, y, cost): graph[x].append((y, cost)) graph[y].append((x, cost)) # The nodes shown in above example (by alphabets) are # implemented using integers add_edge(x, y, cost); add_edge(0, 1, 3) add_edge(0, 2, 6) add_edge(0, 3, 5) add_edge(1, 4, 9) add_edge(1, 5, 8) add_edge(2, 6, 12) add_edge(2, 7, 14) add_edge(3, 8, 7) add_edge(8, 9, 5) add_edge(8, 10, 6) add_edge(9, 11, 1) add_edge(9, 12, 10) add_edge(9, 13, 2) source = 0 target = 9 greedy_best_first_search(source, target, v)  Prolog #  likes(john,flowers). likes(john,chicks). likes(john,mangoes). hates(john,oranges). dislikes(john,study).  week-6 #  valuable(gold). female(jane). owns(jane,gold). father(john,marry). gives(john,book,marry). play(john,marry,football). play(jane,jim,badminton). %2nd example likes(john,flowers). likes(john,chicks). likes(john,mangoes). hates(john,orangs). dislikes(john,study). %family male(albert). male(edward). female(alice). female(victoria). parent(albert,edward). parent(victoria,edward). father(X,Y):- parent(X,Y),female(X). mother(X,Y):- parent(X,Y),female(X). edge(a,b). edge(a,c). edge(b,d). edge(d,e). path(X,Y):- edge(X,Y). path(X,Y):- edge(X,Z),path(Z,Y). female(pam). male(tom). male(bob). female(liz). female(pat). female(ann). male(jim). parent(pam,bob). parent(tom,bob). parent(tom,liz). parent(bob,ann). parent(pat,jim). parent(bob,peter). parent(peter,jim). mother(X,Y):- parent(X,Y),female(X). sister(X,Y):- parent(Z,X),parent(Z,Y),female(X),X\\==Y. father(X,Y):- parent(X,Y),male(X). haschild(X):- parent(X,_). brother(X,Y):-parent(Z,X),parent(Z,Y),male(X),X\\==Y. grandparent(X,Y):- parent(X,Z),parent(Z,Y). grandmother(X,Z):- mother(X,Y),parent(Y,Z). grandfather(X,Z):- father(X,Y),parent(Y,Z). wife(X,Y):- parent(X,Z),parent(Y,Z),female(X),male(Y). uncle(X,Z):- brother(X,Y),parent(Y,Z).  week-7 (Iris-data-set) #  from sklearn import datasets iris = datasets.load_iris() import matplotlib.pyplot as plt _, ax = plt.subplots() scatter = ax.scatter(iris.data[:, 0], iris.data[:, 1], c=iris.target) ax.set(xlabel=iris.feature_names[0], ylabel=iris.feature_names[1]) _ = ax.legend( scatter.legend_elements()[0], iris.target_names, loc=\u0026#34;lower right\u0026#34;, title=\u0026#34;Classes\u0026#34; )     week-8 #     Click GOOGLE COLLAB to view my notebook   week-9 #     Click GOOGLE COLLAB to view my notebook  ","date":"5 November 2023","permalink":"/ai-chapter/ai-lab/","section":"AI-chapters","summary":"AI lab #   Week-1(from list) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week1_listset.","title":"AI lab"},{"content":"","date":"5 November 2023","permalink":"/ai-chapter/","section":"AI-chapters","summary":"","title":"AI-chapters"},{"content":" R Programming Language #   Introduction #  R is a robust programming language and environment designed for statistical computing and data analysis. Developed by Ross Ihaka and Robert Gentleman at the University of Auckland, it has evolved into a versatile tool for professionals in various fields, including statistics, data science, and academia.\n Basics #   R Basics #   Assigning Values #  Use the \u0026lt;- operator to assign values to variables:\nx \u0026lt;- 10  Data Types #  R supports various data types, including numeric, character, logical, and factors.\n Vectors #  Create a numeric vector:\nnumeric_vector \u0026lt;- c(1, 2, 3, 4, 5)  Matrices #  Generate a matrix:\nmatrix_data \u0026lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3)  Data Frames #  Build a data frame:\ndata_frame \u0026lt;- data.frame(Name = c(\u0026#34;John\u0026#34;, \u0026#34;Jane\u0026#34;), Age = c(25, 30))  Basic Operations #   Addition of Two Numbers #  a \u0026lt;- 5 b \u0026lt;- 7 sum_result \u0026lt;- a + b  Subtraction of Two Numbers #  difference_result \u0026lt;- a - b  Multiplication of Two Numbers #  product_result \u0026lt;- a * b  Division of Two Numbers #  quotient_result \u0026lt;- a / b  Data Manipulation #   Data Import/Export #   Reading CSV #  Read data from a CSV file:\ndata \u0026lt;- read.csv(\u0026#34;filename.csv\u0026#34;)  Writing CSV #  Write data to a CSV file:\nwrite.csv(data, \u0026#34;output.csv\u0026#34;)  Data Exploration #   Summary Statistics #  Get summary statistics of a data frame:\nsummary(data)  Head and Tail #  View the first or last few rows of a data frame:\nhead(data) tail(data)  Data Manipulation #   Subset Data #  Subset data based on a condition:\nsubset_data \u0026lt;- data[data$Age \u0026gt; 25, ]  Filter Data (dplyr package) #  Filter data using the dplyr package:\nlibrary(dplyr) filtered_data \u0026lt;- filter(data, Age \u0026gt; 25)  Statistical Analysis #   Descriptive Statistics #   Mean #  Calculate the mean of a variable:\nmean(data$variable)  Median #  Calculate the median of a variable:\nmedian(data$variable)  Hypothesis Testing #   t-test #  Perform a t-test between two groups:\nt.test(variable ~ group, data = data)  ANOVA #  Perform ANOVA:\nanova_model \u0026lt;- aov(variable ~ group, data = data) summary(anova_model)  Data Visualization #   Base Plotting #   Scatter Plot #  Create a scatter plot using base plotting:\nplot(data$X, data$Y, main = \u0026#34;Scatter Plot\u0026#34;, xlab = \u0026#34;X-axis\u0026#34;, ylab = \u0026#34;Y-axis\u0026#34;)  Histogram #  Create a histogram using base plotting:\nhist(data$variable, main = \u0026#34;Histogram\u0026#34;, xlab = \u0026#34;Value\u0026#34;, col = \u0026#34;lightblue\u0026#34;)  ggplot2 #   Scatter Plot #  Create a scatter plot using the ggplot2 package:\nlibrary(ggplot2) ggplot(data, aes(x = X, y = Y)) + geom_point() + labs(title = \u0026#34;Scatter Plot\u0026#34;, x = \u0026#34;X-axis\u0026#34;, y = \u0026#34;Y-axis\u0026#34;)  Boxplot #  Create a boxplot using the ggplot2 package:\nggplot(data, aes(x = group, y = variable)) + geom_boxplot() + labs(title = \u0026#34;Boxplot\u0026#34;, x = \u0026#34;Group\u0026#34;, y = \u0026#34;Variable\u0026#34;) ","date":"5 November 2023","permalink":"/ds-chapter/basic-r/","section":"DS-chapters","summary":"R Programming Language #   Introduction #  R is a robust programming language and environment designed for statistical computing and data analysis.","title":"Basic R"},{"content":"  Data Science #   Introduction to Data Science #   Definition #  Data Science is an interdisciplinary field that leverages scientific methods, processes, algorithms, and systems to extract insights and knowledge from structured and unstructured data.\n Significance #   Informed Decision Making: Data Science enables organizations to make informed decisions based on data-driven insights. Predictive Analysis: It allows for the prediction of future trends and outcomes. Pattern Recognition: Identifying patterns and correlations within data for a deeper understanding. Optimizing Processes: Improves efficiency and effectiveness by optimizing processes through data analysis. Competitive Advantage: Provides a competitive edge by uncovering hidden opportunities and risks.   Linear Algebra for Data Science #   Scalars, Vectors, Matrices, and Tensors #   Scalars: Single numerical values. Vectors: Ordered arrays of numbers. Matrices: 2D arrays of numbers. Tensors: Generalization of scalars, vectors, and matrices to higher dimensions.   Operations in Linear Algebra #   Scalar Multiplication and Addition: Multiply or add a scalar to a matrix. Matrix Multiplication: Dot product of matrices. Transpose: Swapping rows and columns of a matrix.   Problem 1: #  Perform scalar multiplication on the matrix \\(A = \\begin{bmatrix} 2 \u0026amp; 3 \\ 4 \u0026amp; 1 \\end{bmatrix}\\) with the scalar \\(k = 3\\).\nSolution: \\[ kA = \\begin{bmatrix} 6 \u0026amp; 9 \\ 12 \u0026amp; 3 \\end{bmatrix} \\]\n Problem 2: #  Given matrices \\(B = \\begin{bmatrix} 1 \u0026amp; -2 \\ 3 \u0026amp; 0 \\end{bmatrix}\\) and \\(C = \\begin{bmatrix} 4 \u0026amp; 1 \\ -1 \u0026amp; 2 \\end{bmatrix}\\), calculate the product \\(BC\\).\nSolution: \\[ BC = \\begin{bmatrix} 3 \u0026amp; 0 \\ 11 \u0026amp; 2 \\end{bmatrix} \\]\n Linear Equations #   Definition #  A linear equation is an algebraic equation in which each term is either a constant or the product of a constant and a variable.\n Standard Form #  \\[ a_1x_1 + a_2x_2 + \\ldots + a_nx_n = b \\]\n Solving Linear Equations #   Substitution Method: Solve one equation for one variable and substitute into the other. Elimination Method: Eliminate one variable by adding or subtracting equations. Matrix Method: Represent the system of equations as a matrix and solve.   Problem 3: #  Solve the system of equations: \\[ 2x + y = 8 \\] \\[ 3x - 2y = 1 \\]\nSolution: Multiplying the first equation by 2 and adding the second equation, we get \\(7x = 9\\), leading to \\(x = \\frac{9}{7}\\). Substituting \\(x\\) back, we find \\(y = \\frac{5}{7}\\).\n Problem 4: #  Express the following linear equation in standard form: \\[ 4x - 2y + 6z = 10 \\]\nSolution: Rearranging the given equation, we get: [ 4x - 2y + 6z - 10 = 0 \\]\n Distance #   Euclidean Distance #  \\[ d(x, y) = \\sqrt{\\sum_{i=1}^{n}(x_i - y_i)^2} \\]\n Manhattan Distance (L1 Norm) #  \\[ d(x, y) = \\sum_{i=1}^{n}|x_i - y_i| \\]\n Minkowski Distance #  \\[ d(x, y) = \\left(\\sum_{i=1}^{n}|x_i - y_i|^p\\right)^{\\frac{1}{p}} \\]\n Problem 5: #  Calculate the Euclidean distance between points \\(P(2, 5)\\) and \\(Q(7, 1)\\).\nSolution: \\[ d(P, Q) = \\sqrt{(7-2)^2 + (1-5)^2} = \\sqrt{25 + 16} = \\sqrt{41} \\]\n Problem 6: #  Determine the Manhattan distance between vectors \\(V = [2, -3, 5]\\) and \\(W = [1, 4, -2]\\).\nSolution: \\[ d(V, W) = |2-1| + |-3-4| + |5-(-2)| = 1 + 7 + 7 = 15 \\]\n Eigenvalues and Eigenvectors #   Definition #   Eigenvalues ((\\lambda)): Scalar values that represent how a linear transformation changes. Eigenvectors ((v)): Vectors that remain unchanged in direction after a linear transformation.   Calculation #  \\[ Av = \\lambda v \\] where \\(A\\) is a square matrix.\n Problem 7: #  Given a matrix \\(D = \\begin{bmatrix} 3 \u0026amp; 1 \\ 1 \u0026amp; 2 \\end{bmatrix}\\), find its eigenvalues and corresponding eigenvectors.\nSolution: The characteristic equation leads to \\(\\lambda^2 - 5\\lambda + 5 = 0\\), with solutions \\(\\lambda_1 = 1\\) and \\(\\lambda_2 = 4\\).\nFor \\(\\lambda_1 = 1\\), solving \\( (D - I)v = 0\\) gives \\(v_1 = \\begin{bmatrix} -1 \\ 1 \\end{bmatrix}\\).\nFor \\(\\lambda_2 = 4\\), solving \\( (D - 4I)v = 0\\) gives \\(v_2 = \\begin{bmatrix} 1 \\ 1 \\end{bmatrix}\\).\n Dimensionality Reduction #   Motivation #   Curse of Dimensionality: Increasing dimensions may lead to sparsity and computational challenges. Feature Selection and Extraction: Retain important information while reducing dimensionality.   Techniques #   Principal Component Analysis (PCA): Linear transformation to convert data into a new coordinate system. t-Distributed Stochastic Neighbor Embedding (t-SNE): Non-linear technique for visualizing high-dimensional data.   Problem 8: #  Apply PCA to reduce the dimensionality of a dataset with 4 features to 2 dimensions.\nSolution:\n Compute Covariance Matrix: Calculate the covariance matrix of the dataset. Find Eigenvectors and Eigenvalues: Find the eigenvectors and eigenvalues of the covariance matrix. Sort Eigenvectors by Eigenvalues: Sort the eigenvectors based on their corresponding eigenvalues. Select Top (k) Eigenvectors: Choose the top (k) eigenvectors to form the transformation matrix. Transform Data: Multiply the original data by the transformation matrix to obtain the reduced-dimensional data.   t-Distributed Stochastic Neighbor Embedding (t-SNE) #   Problem #  9: Explain the motivation behind using t-SNE for dimensionality reduction and provide a step-by-step overview of the t-SNE algorithm.\nSolution: t-SNE is motivated by the need to visualize high-dimensional data in a lower-dimensional space while preserving local relationships. Here\u0026rsquo;s a step-by-step overview:\n Define Pairwise Similarities: Compute pairwise similarities between data points in the high-dimensional space using a Gaussian distribution. Define Pairwise Similarities in Low-Dimensional Space: Compute pairwise similarities in the low-dimensional space using a Student\u0026rsquo;s t-distribution. Optimization: Minimize the difference between the pairwise similarities in the high-dimensional and low-dimensional spaces using gradient descent. Visualization: Map the data points to the lower-dimensional space for visualization.   ","date":"5 November 2023","permalink":"/ds-chapter/ds-chapter-1/","section":"DS-chapters","summary":"Data Science #   Introduction to Data Science #   Definition #  Data Science is an interdisciplinary field that leverages scientific methods, processes, algorithms, and systems to extract insights and knowledge from structured and unstructured data.","title":"DS chapter-1"},{"content":"","date":"5 November 2023","permalink":"/ds-chapter/","section":"DS-chapters","summary":"","title":"DS-chapters"},{"content":" Detailed explanation of commonly used Git commands #   Configuration #   Configure User Information #  Set your name and email address that will be associated with your Git commits:\ngit config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;youremail@example.com\u0026#34;  git config is used to set configuration options in Git. --global flag sets the configuration globally for your user.   Creating a Repository #   Initialize a New Repository #  Create a new Git repository in the current directory:\ngit init  git init initializes a new Git repository in the current directory, creating a .git subdirectory that stores Git configuration and version history.   Making Changes #   Add Changes to Staging #  Add modified files to the staging area, preparing them for the next commit:\ngit add \u0026lt;file\u0026gt;  git add stages changes for the next commit. You can specify individual files or directories.   Commit Changes #  Create a commit with staged changes:\ngit commit -m \u0026#34;Your commit message\u0026#34;  git commit creates a new commit with the changes that are in the staging area. The -m flag is used to provide a commit message that briefly describes the changes.   Viewing Status and History #   Check Status #  View the status of your working directory:\ngit status  git status provides information about changes in your working directory and the staging area.   View Commit History #  Display commit history:\ngit log  git log shows a chronological list of commits in the repository, including commit messages, authors, and commit hashes.   Branching and Merging #   Create a New Branch #  Create a new branch based on the current branch:\ngit branch \u0026lt;branchname\u0026gt;  git branch is used to create a new branch. Specify the branch name to create a new branch.   Switch Branch #  Switch to a different branch:\ngit checkout \u0026lt;branchname\u0026gt;  git checkout allows you to switch between branches. Specify the branch name to switch to that branch.   Merge Branch #  Merge changes from one branch into the current branch:\ngit merge \u0026lt;branchname\u0026gt;  git merge combines changes from the specified branch into the current branch, creating a new commit with the merged changes.   Delete Branch #  Delete a branch:\ngit branch -d \u0026lt;branchname\u0026gt;  git branch -d is used to delete a branch that is no longer needed. Use -d to delete a branch if it has been fully merged into other branches.   Remote Repositories #   Add a Remote #  Add a remote repository to your Git configuration:\ngit remote add origin \u0026lt;remote-url\u0026gt;  git remote is used to manage remote repositories. add specifies that you want to add a remote. origin is the commonly used name for the remote, but you can choose a different name. \u0026lt;remote-url\u0026gt; is the URL of the remote repository.   Fetch Changes #  Fetch changes from a remote repository:\ngit fetch  git fetch downloads objects and references from another repository, updating your remote-tracking branches without modifying your working directory.   Push Changes #  Push local changes to a remote repository:\ngit push origin \u0026lt;branchname\u0026gt;  git push sends your local changes to a remote repository. origin is the name of the remote repository. \u0026lt;branchname\u0026gt; specifies the branch you want to push.   Pull Changes #  Pull changes from a remote repository and merge them into your local branch:\ngit pull  git pull combines git fetch and git merge to update your local branch with changes from a remote repository.   Collaborating #   Clone a Repository #  Clone a remote repository to your local machine:\ngit clone \u0026lt;repository-url\u0026gt;  git clone creates a local copy of a remote repository on your computer.   Fork a Repository #  Fork a repository on a platform like GitHub to create your own copy. This is not a Git command but a common step when contributing to open-source projects.\n Create a Pull Request #  Create a pull request to propose changes to the original repository. This is done on platforms like GitHub and GitLab, not through Git commands.\n Review and Merge #  Review pull requests and merge changes in a collaborative environment. This also happens on platforms like GitHub and GitLab, not through Git commands.\n Miscellaneous #   Ignore Files #  Create a .gitignore file to specify which files or directories should be ignored by Git. You can list file patterns, directories, or file extensions that Git should not track.\n View Differences #  View the differences between files in your working directory and the most recent commit:\ngit diff  git diff shows the differences between your working directory and the last committed state.   Help #  Get help on a specific Git command:\ngit --help \u0026lt;command\u0026gt;  Use git --help followed by the command name to get detailed information about a specific Git command.  This detailed explanation covers commonly used Git commands for version control. For more in-depth documentation, you can refer to the Git documentation\n","date":"5 November 2023","permalink":"/posts/git-guide/","section":"Posts","summary":"Detailed explanation of commonly used Git commands #   Configuration #   Configure User Information #  Set your name and email address that will be associated with your Git commits:","title":"Git Guide"},{"content":"  1st Answer  Increased Ability to Express Ideas  Depth of thought influenced by language expressiveness. Difficulty conceptualizing structures without descriptive language. Limits on control structures, data structures, and abstractions based on the development language. Awareness of a variety of language features reduces limitations in software development. Exploration of language constructs and their simulation in languages lacking direct support.    Improved Background for Choosing Appropriate Languages  Programmers tend to favor familiar languages, even if unsuitable for new projects. Familiarity with a range of languages empowers informed language selection.    Greater Ability to Learn New Languages  Continuous evolution of programming languages necessitates ongoing learning. Understanding object-oriented programming facilitates learning languages like Java. Thorough comprehension of fundamental language concepts eases adaptation to new languages.     Understand Significance of Implementation  Insight into implementation issues illuminates the design rationale of languages. Enables intelligent use of a language according to its intended design.     Ability to Design New Languages  Knowledge of multiple languages enhances understanding of programming language concepts. Proficiency in designing new languages based on comprehensive knowledge.     Overall Advancement of Computing  Instances where language popularity did not align with conceptual superiority. Historical example: ALGOL 60 vs. Fortran, possibly influenced by lack of understanding of ALGOL 60\u0026rsquo;s conceptual design. Consideration of external factors, such as IBM\u0026rsquo;s role.     Scientific Applications  Invention of computers in the 40s for scientific applications. Requirement for large-scale floating-point computations. Fortran as the first language developed for scientific applications. ALGOL 60 intended for similar use.     Business Applications  COBOL as the first successful language for business applications. Emphasis on report generation, decimal arithmetic, and character manipulation. Arrival of PCs led to new ways for businesses to use computers. Development of spreadsheets and database systems for business applications.     Artificial Intelligence  Symbolic computations in AI, favoring linked lists over arrays. LISP as the first widely used AI programming language.     Systems Programming  O/S and programming support tools collectively known as system software. Efficiency crucial due to continuous use.     Scripting Languages  Scripting involves putting a list of commands (script) in a file for execution. Example: PHP, a scripting language used on web server systems. Code embedded in HTML documents, interpreted on the server before sending to the requesting browser.       2nd answer  Language Evaluation Criteria  Readability 1. Software development was largely thought of in terms of writing code (LOC). 2. Language constructs designed more from the point of view of computers than users. 3. Readability became crucial for ease of maintenance. 4. Shift from machine orientation to human orientation.    Overall Simplicity - Too many features make the language difficult to learn. - Multiplicity of features complicates the language. - Example: Java has multiple ways to increment a variable. - Operator overloading can reduce readability if not used sensibly.    Orthogonality 1. Makes the language easy to learn and read. 2. Meaning is context-independent. 3. A relatively small set of primitive constructs can be combined in a relatively small number of ways. 4. Every possible combination is legal and meaningful. 5. ALGOL 68 is an example of highly orthogonal design. 6. However, excessive orthogonality can lead to unnecessary complexity.    Control Statements - Indiscriminate use of goto statements reduced program readability. - Example: Nested loops in C. - Control statement design is now less important for readability than in the past.    Data Types and Structures - Adequate facilities for defining data types and structures are significant aids to reliability. - Example: Boolean type.    Syntax Considerations - Syntax affects readability. - Examples: Identifier forms, special words, form and meaning alignment.     Writability  Simplicity and Orthogonality - A smaller number of primitive constructs with consistent rules is better. - Support for abstraction allows ignoring details in complicated structures or operations. - Process abstraction is using a subprogram to implement a task instead of replicating it. - Expressivity means having convenient ways of specifying computations.    Reliability - A program is reliable if it performs to specifications under all conditions. - Type checking detects type errors, enhancing reliability. - Exception handling aids in intercepting run-time errors. - Aliasing (multiple references to the same memory cell) is considered dangerous. - Readability and writability influence reliability.    Cost - Categories affecting cost: training, writing, compiling, executing, language implementation system. - Reliability impacts cost (maintenance costs can be high). - Portability and generality influence cost.       6th answer  Ambiguity in Grammar: #  In the context of formal grammars, ambiguity refers to a situation where the same sequence of symbols in a programming language can be parsed in more than one way. It introduces uncertainty and makes it challenging for the parser to determine the correct syntactic structure of the input.\n Characteristics of Ambiguous Grammars: #    Multiple Parse Trees: Ambiguous grammars can generate multiple parse trees for a single input string.\n  Parsing Conflicts: Parsing becomes ambiguous when there are multiple possibilities for the next production to apply during the parsing process.\n   Differences between Ambiguous and Unambiguous Grammars: #     Feature Ambiguous Grammar Unambiguous Grammar     Definition Allows multiple interpretations for the same input Provides a unique parse tree for each input   Parse Trees Can have multiple parse trees for a single input Has a unique parse tree for each valid input   Clarity May introduce confusion in understanding syntax Offers clarity and a straightforward structure   Parsing Difficulty Generally harder to parse due to multiple choices Easier to parse as there is a clear parsing path   Example The classic example is the ambiguous arithmetic expression grammar where \u0026ldquo;3 + 5 * 2\u0026rdquo; can be parsed in different ways A simple arithmetic expression grammar where the order of operations is well-defined   Ambiguity Resolution Requires additional rules or disambiguation techniques to resolve ambiguity No need for disambiguation techniques, as there is a unique parsing path   Precedence and Associativity Ambiguity may arise in operator precedence and associativity Well-defined rules for operator precedence and associativity ensure unambiguous parsing       7th answer  De-notational Semantics  Based on recursive function theory, the most abstract semantics description method. Originally developed by Scott and Strachey.   The Process of Building a De-notational Specification 1. Define a mathematical object for each language entity. 2. Define a function that maps instances of language entities onto instances of corresponding mathematical objects.    The meaning of language constructs is defined by the values of the program\u0026rsquo;s variables. Difference between denotational and operational semantics: In operational semantics, state changes are defined by coded algorithms; in denotational semantics, they are defined by rigorous mathematical functions.   State of a Program - The state of a program is the values of all its current variables, represented as `s = {\u0026lt;i1, v1\u0026gt;, \u0026lt;i2, v2\u0026gt;, ..., \u0026lt;in, vn\u0026gt;}`. - `VARMAP` is a function that, given a variable name and a state, returns the current value of the variable: `VARMAP (ij, s) = vj`.    Decimal Numbers - `\u0026lt;dec_num\u0026gt;` can be 0, 1, 2, ..., 9 or `\u0026lt;dec_num\u0026gt;` followed by (0, 1, 2, ..., 9). - `Mdec` functions map decimal numbers to their corresponding values.    Expressions - `Me(\u0026lt;expr\u0026gt;, s)` evaluates expressions based on their types: - `\u0026lt;dec_num\u0026gt;`: `Mdec(\u0026lt;dec_num\u0026gt;, s)` - `\u0026lt;var\u0026gt;`: `VARMAP(\u0026lt;var\u0026gt;, s)` - `\u0026lt;binary_expr\u0026gt;`: Operates based on the operator.    Assignment Statements - `Ma(x := E, s)` assigns the value of expression `E` to variable `x` in state `s`.    Logical Pretest Loops - `Ml(while B do L, s)` represents the meaning of a pretest loop. - The loop is converted from iteration to recursion, mathematically defined by recursive state mapping functions.    Evaluation of De-notational Semantics - Can be used to prove the correctness of programs. - Provides a rigorous way to think about programs. - Can aid in language design. - Used in compiler generation systems.     Axiomatic Semantics  Based on formal logic (first-order predicate calculus). Original purpose: formal program verification. Approach: Define axioms or inference rules for each statement type in the language. Expressions are called assertions. An assertion before a statement (precondition) states relationships and constraints among variables. An assertion after a statement is a postcondition. Weakest precondition is the least restrictive precondition guaranteeing the postcondition.   Pre-Post Form: {P} statement {Q} - Example: `a := b + 1 {a \u0026gt; 1}`. - One possible precondition: `{b \u0026gt; 10}`. - Weakest precondition: `{b \u0026gt; 0}`.    Program Proof Process - Postcondition for the whole program is the desired result. - Work back through the program to the first statement. - If the precondition on the first statement matches the program spec, the program is correct.    Inference Rule for Logical Pretest Loops - For the loop construct: `{P} while B do S end {Q}`. - Inference rule involves a loop invariant (I). - Characteristics of the loop invariant: - `P =\u0026gt; I` (initially true). - `{I} B {I}` (Boolean evaluation does not change the validity of I). - `{I and B} S {I}` (I is not changed by executing the loop body). - `(I and (not B)) =\u0026gt; Q` (if I is true and B is false, Q is implied). - Loop termination (can be difficult to prove). - I is a weakened version of the loop postcondition and also a precondition.    Evaluation of Axiomatic Semantics - Developing axioms or inference rules for all statements in a language is challenging. - Good for correctness proofs and an excellent framework for reasoning about programs. - Not as useful for language users and compiler writers.     Attribute Grammar Attributes  actual_type: synthesized for \u0026lt;var\u0026gt; and \u0026lt;expr\u0026gt; expected_type: inherited for \u0026lt;expr\u0026gt;    How are attribute values computed?  If all attributes were inherited, the tree could be decorated in top-down order. If all attributes were synthesized, the tree could be decorated in bottom-up order. In many cases, both kinds of attributes are used, and it is some combination of top-down and bottom-up that must be used.   Attribute Dependencies - `\u0026lt;expr\u0026gt;.env` inherited from parent - `\u0026lt;expr\u0026gt;.expected_type` inherited from parent - `\u0026lt;var\u0026gt;[1].env` depends on `\u0026lt;expr\u0026gt;.env` - `\u0026lt;var\u0026gt;[2].env` depends on `\u0026lt;expr\u0026gt;.env` - `\u0026lt;var\u0026gt;[1].actual_type`: `lookup(A, \u0026lt;var\u0026gt;[1].env)` - `\u0026lt;var\u0026gt;[2].actual_type`: `lookup(B, \u0026lt;var\u0026gt;[2].env)` - `\u0026lt;var\u0026gt;[1].actual_type =? \u0026lt;var\u0026gt;[2].actual_type` - `\u0026lt;expr\u0026gt;.actual_type`: `\u0026lt;var\u0026gt;[1].actual_type` - `\u0026lt;expr\u0026gt;.actual_type =? \u0026lt;expr\u0026gt;.expected_type`       8th answer  Difference Certainly! Here's a table differentiating between a compiler and an interpreter:    Feature Compiler Interpreter     Translation Translates the entire source code before execution Translates line by line or statement by statement during execution   Execution Speed Generally produces faster machine code for execution Generally slower as it interprets code at runtime   Output Generates an intermediate machine code or executable file No separate executable file; interprets code directly   Errors All errors are reported after the entire code is translated Stops at the first encountered error, reports it, and halts execution   Memory Usage Generally requires more memory during compilation Typically uses less memory during interpretation   Platform Dependency Generates platform-specific machine code More portable as it interprets source code directly   Debugging May be more challenging due to the generated machine code Easier to debug as errors are reported line by line   Examples C, C++, Java Python, JavaScript, Ruby      Progg enev # Summary: Programming Environments Programming Environments: A programming environment encompasses the collection of tools utilized in software development.\nUNIX:\n An older operating system and tool collection with a rich history in software development.  Borland JBuilder:\n An integrated development environment designed for Java programming.  Microsoft Visual Studio.NET:\n A comprehensive and intricate visual environment. Supports programming in languages such as C#, Visual BASIC.NET, Jscript, J#, or C++.  For a deeper understanding of the evolution and relationships between common high-level programming languages, further exploration into the \u0026ldquo;Genealogy of common high-level programming languages\u0026rdquo; is recommended.\n  Aliasing # Aliasing in Programming   Definition: Aliasing occurs when two or more different names or references are used to access the same memory location or variable.\n  Consequence: Changes made through one identifier can affect the data accessed through another identifier.\n  Common in Pointers/References: Aliasing is often associated with languages that allow direct memory manipulation, such as C or C++, especially when using pointers or references.\n  Example: If two pointers point to the same memory location, modifications through one pointer will be reflected when accessing the data through the other pointer.\n  Side Effects: Aliasing can lead to unintended side effects and make code more error-prone, as the program may not behave as expected due to shared data.\n  Management: Careful management or avoidance of aliasing is crucial for writing robust and predictable code, particularly in situations where pointers or references are extensively used.\n  Language-Specific Approaches: Some programming languages, like Java, implement mechanisms to minimize or prevent aliasing, contributing to increased code safety.\n    categories of pl # refer 1st ans   ","date":"5 November 2023","permalink":"/ppl-chapter/ppl-quiz/","section":"PPL-chapters","summary":"1st Answer  Increased Ability to Express Ideas  Depth of thought influenced by language expressiveness.","title":"PPL QUIZ"},{"content":"","date":"5 November 2023","permalink":"/ppl-chapter/","section":"PPL-chapters","summary":"","title":"PPL-chapters"},{"content":" Basic vim setup #   [!NOTE] Note Paste the below code in vimrc file\n syntax onfiletype plugin indent onset modelines=0set numberset rulerset visualbellset encoding=utf-8set wrapset textwidth=79set formatoptions=tcqrn1set tabstop=2set shiftwidth=2set softtabstop=2set expandtabset noshiftround\u0026#34; Cursor motionset scrolloff=3set backspace=indent,eol,startset matchpairs+=\u0026lt;:\u0026gt;runtime! macros/matchit.vimnnoremap j gjnnoremap k gkset hiddenset ttyfast\u0026#34; Status barset laststatus=2\u0026#34; Last lineset showmodeset showcmd\u0026#34; Searchingnnoremap / /\\vvnoremap / /\\vset hlsearchset incsearchset ignorecaseset smartcaseset showmatchmap \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt; :let @/=\u0026#39;\u0026#39;\u0026lt;cr\u0026gt; \u0026#34; clear search\u0026#34; Visualize tabs and newlinesset listchars=tab:â–¸\\ ,eol:Â¬\u0026#34; Uncomment this to enable by default:\u0026#34; set list \u0026#34; To enable by default\u0026#34; Or use your leader key + l to toggle on/offmap \u0026lt;leader\u0026gt;l :set list!\u0026lt;CR\u0026gt; \u0026#34; Toggle tabs and EOL Here is the complete breakdown: #  syntax on syntax on enables syntax highlighting in Vim. This highlights different elements of your code with different colors to make it more readable and easier to understand.  filetype plugin indent on filetype plugin indent on enables file type detection, which allows Vim to automatically detect the type of file you are editing and apply appropriate settings and plugins for that file type. It also enables automatic indentation based on the file type.  set modelines=0 set modelines=0 disables the reading of modelines. Modelines are special comments in a file that can be used to specify settings for that file. Setting this to 0 means Vim won\u0026rsquo;t read and apply settings from modelines.  set number set number displays line numbers on the left side of the editor, making it easier to reference specific lines in the file.  set ruler set ruler displays the current line and column number in the status line at the bottom of the Vim window.  set visualbell set visualbell replaces the audible bell with a visual bell. When an error or warning occurs, Vim will flash the screen instead of producing a sound.  set encoding=utf-8 set encoding=utf-8 sets the character encoding to UTF-8, which is a widely used encoding for handling a wide range of characters from different languages.  set wrap set wrap enables line wrapping, causing long lines to wrap to the next line if they exceed the screen width.  set textwidth=79 set textwidth=79 sets the maximum line width to 79 characters. This can be useful for ensuring that your code conforms to a specific line length limit.  set formatoptions=tcqrn1 set formatoptions=tcqrn1 sets various formatting options for auto-indentation and text formatting. These options control how Vim formats text as you type.  set tabstop=2set shiftwidth=2set softtabstop=2set expandtabset noshiftround These lines configure indentation settings. They set the tab width to 2 spaces, the number of spaces to use for each level of indentation, and configure tabs to be expanded as spaces.  \u0026#34; Cursor motionset scrolloff=3 set scrolloff=3 configures Vim to keep at least 3 lines of context when scrolling up or down. This helps maintain context while navigating through the file.  set backspace=indent,eol,start set backspace=indent,eol,start allows you to use the Backspace key to delete characters beyond the current indent, at the end of a line, and at the start of insert mode.  set matchpairs+=\u0026lt;:\u0026gt;runtime! macros/matchit.vim These lines configure matching pairs for brackets (\u0026lt;:\u0026gt;). It also loads the matchit.vim plugin, which enhances Vim\u0026rsquo;s ability to jump between matching pairs of characters using the % key.  nnoremap j gjnnoremap k gk These lines create non-recursive key mappings for j and k to make them move by display lines (gj and gk) instead of actual lines. This can be useful when working with wrapped lines.  set hidden set hidden allows you to switch between buffers without saving changes. Unsaved changes are preserved in the background.  set ttyfast set ttyfast optimizes Vim for faster terminal response.  \u0026#34; Status barset laststatus=2 set laststatus=2 ensures that the status bar is always displayed with at least two lines.  \u0026#34; Last lineset showmodeset showcmd These lines enable the display of the current mode (e.g., Normal, Insert) and show partial command input at the bottom of the screen.  \u0026#34; Searchingnnoremap / /\\vvnoremap / /\\vset hlsearchset incsearchset ignorecaseset smartcaseset showmatchmap \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt; :let @/=\u0026#39;\u0026#39;\u0026lt;cr\u0026gt; \u0026#34; clear search These lines configure various aspects of searching and search highlighting in Vim. They also create key mappings for search-related commands and provide a mapping to clear the search pattern using \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt;.  \u0026#34; Visualize tabs and newlinesset listchars=tab:â–¸\\ ,eol:Â¬\u0026#34; Uncomment this to enable by default:\u0026#34; set list \u0026#34; To enable by default\u0026#34; Or use your leader key + l to toggle on/offmap \u0026lt;leader\u0026gt;l :set list!\u0026lt;CR\u0026gt; \u0026#34; Toggle tabs and EOL These lines configure how tabs and newlines are visualized. They use special characters to represent tabs (â–¸) and end-of-line characters (Â¬). Additionally, there\u0026rsquo;s a key mapping to toggle the visualization of tabs and EOL characters using \u0026lt;leader\u0026gt;l.  This .vimrc file provides various settings and key mappings to enhance your Vim experience. You can customize it further to suit your preferences.\n","date":"5 November 2023","permalink":"/posts/vim-setup/","section":"Posts","summary":"Basic vim setup #   [!","title":"Vim Setup for Competitive Programming"},{"content":" Knowledge, Reasoning \u0026amp; Planning #   Reasoning #   Knowledge-Based Agent #    A knowledge-based agent is a sophisticated system designed to utilize knowledge for decision-making and problem-solving.\n  Components:\n  Knowledge Base (KB): A repository of information about the world, often represented in a formal language.\n  Inference Engine: Processes information from the knowledge base to draw conclusions and make decisions.\n  Sensors: Collect data from the environment.\n  Actuators: Execute actions based on conclusions drawn.\n    Reasoning techniques include logical and probabilistic reasoning.\n   Propositional Logic #    Propositional logic deals with propositions, which are statements that are either true or false.\n  Variables represent propositions, and logical connectives (AND, OR, NOT) are used to form compound propositions.\n  Propositional logic is suitable for expressing relationships and conditions in a simple, binary manner.\n   Inference #    Inference is the process of deriving new information from existing knowledge.\n  In propositional logic, inference can involve both deduction and induction.\n  Deductive inference derives conclusions that must be true if the premises are true, based on logical rules.\n  Inductive inference involves making generalizations based on patterns observed in specific examples.\n   Predicate Logic (First Order Logic) #    Predicate logic, or first-order logic, extends propositional logic by introducing variables, quantifiers, and predicates.\n  Variables represent objects, quantifiers (existential and universal) specify the scope of variables, and predicates represent relationships.\n  It allows for a more expressive representation of knowledge and is commonly used in AI.\n   Resolution #    Resolution is a logical inference technique in predicate logic.\n  It involves the resolution rule, which eliminates redundant clauses and facilitates the derivation of new clauses.\n  Resolution is a foundational step in automated theorem proving and logical reasoning.\n   Structured Knowledge Representation #   Frames #    Frames provide a structured way to represent knowledge about objects and concepts.\n  A frame consists of slots (attributes) and values associated with those slots.\n  Frames are used for organizing and representing complex, hierarchical relationships.\n   Semantic Nets #    Semantic nets, or semantic networks, offer a graphical representation of knowledge using nodes and links.\n  Nodes represent concepts, and links represent relationships between concepts.\n  Semantic nets provide a visual and intuitive representation of semantic relationships.\n   Planning #   A Simple Planning Agent #    A planning agent formulates and executes plans to achieve specific goals.\n  Components include:\n  Goal formulation: Defining the desired outcome.\n  Problem formulation: Representing the initial state, goal state, and possible actions.\n  Search for a solution: Exploring the state space to find a sequence of actions from the initial to the goal state.\n     From Problem Solving to Planning #    Planning involves reasoning about actions and their consequences to achieve goals.\n  In contrast to problem-solving agents, planning agents operate in dynamic environments with changing states.\n  Planning requires generating action sequences that transform an initial state into a desired goal state.\n   Basic Representation of Plans #    Plans are representations of sequences of actions or steps that an agent can execute to achieve a goal.\n  Plans can be represented as lists of actions or in a structured format.\n  A complete and feasible plan is necessary for achieving goals in dynamic environments.\n   Partial Order Planning #    Partial Order Planning allows for flexibility in the execution order of actions.\n  Instead of a strict linear order, actions are partially ordered based on dependencies and constraints.\n  Partial Order Planning is valuable in environments with uncertain action effects.\n   Hierarchical Planning #    Hierarchical Planning organizes plans into hierarchies with subgoals and subplans.\n  Subgoals are intermediate objectives contributing to the overall goal.\n  Hierarchical Planning simplifies the representation of complex plans.\n  ","date":"4 November 2023","permalink":"/ai-chapter/ai-chapter-2/","section":"AI-chapters","summary":"Knowledge, Reasoning \u0026amp; Planning #   Reasoning #   Knowledge-Based Agent #    A knowledge-based agent is a sophisticated system designed to utilize knowledge for decision-making and problem-solving.","title":"AI chapter-2"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]