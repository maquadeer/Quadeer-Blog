[{"content":"","date":"9 November 2023","permalink":"/","section":"Abdul Quadeer's blog","summary":"","title":"Abdul Quadeer's blog"},{"content":" Data Communication Components #   Representation of Data Communication #    Data communication involves the exchange of information between two or more devices using a communication medium.\n  Components include:\n  Message: The information or data being communicated.\n  Sender: Initiates the communication by creating and sending the message.\n  Receiver: Receives and interprets the message sent by the sender.\n  Transmission Medium: The physical path through which the message travels.\n     Flow of Networks #   The flow of networks refers to the intricate process of data transfer between devices in a network.    Data Generation:\n The process begins with the generation of data by a device. This data could be in various forms such as text, images, audio, or video.    Data Encoding and Formatting:\n Before transmission, the data is encoded into a format suitable for transmission. Formatting includes adding necessary headers, footers, or error-checking codes.    Data Transmission:\n The formatted data is then transmitted from the sender to the receiver over the communication medium. This involves the conversion of digital data into analog signals for transmission over analog channels.    Signal Propagation:\n The signals travel through the transmission medium. This could be physical cables, optical fibers, or wireless channels.    Routing:\n In the network, the process of determining the most efficient path for data to travel is called routing. Routers play a crucial role in forwarding data between different networks.    Signal Reception:\n The receiving device captures the transmitted signals. In the case of wireless communication, this involves the reception of radio waves or microwaves.    Signal Decoding:\n The received signals are decoded to retrieve the original digital data. Decoding involves reversing the encoding and formatting applied at the sender\u0026rsquo;s end.    Error Detection and Correction:\n The received data may undergo error detection and correction processes. Techniques like parity checks or checksums are employed to ensure data integrity.    Error Handling:\n If errors are detected, various error-handling mechanisms come into play. This may involve retransmission of data, requesting missing pieces, or applying error correction algorithms.    Response Handling:\n Once the data is successfully received and decoded, the receiving device generates a response. The response may confirm successful data reception or indicate an issue that needs attention.    Data Decryption (if encrypted):\n If the data was encrypted during transmission, the receiving device decrypts it using the appropriate decryption key.    Data Interpretation:\n The final step involves interpreting the received data, making it meaningful for the receiving device or application.    Security Considerations:\n Throughout the entire process, security measures are implemented to protect data from unauthorized access, interception, or tampering. This may involve encryption, secure protocols, and authentication mechanisms.     Layered Architecture #   OSI Model #    The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes the functions of a telecommunication or computing system into seven abstraction layers.\n  Layers of the OSI model:\n  Physical Layer: Deals with the physical connection and transmission of raw bits over a physical medium.\n  Data Link Layer: Responsible for creating a reliable link between two directly connected nodes, providing error detection and correction.\n  Network Layer: Manages the routing and forwarding of data packets between devices across different networks.\n  Transport Layer: Ensures end-to-end communication, including error recovery and flow control.\n  Session Layer: Manages sessions or connections between applications on different devices.\n  Presentation Layer: Handles data format translation, encryption, and compression.\n  Application Layer: Provides network services directly to end-users or applications.\n     TCP/IP Model #    The TCP/IP (Transmission Control Protocol/Internet Protocol) model is the foundation of the Internet.\n  Layers of the TCP/IP model:\n  Link Layer (equivalent to OSI\u0026rsquo;s Data Link and Physical layers): Deals with the physical and data link aspects of network communication.\n  Internet Layer (equivalent to OSI\u0026rsquo;s Network Layer): Manages the routing and addressing of data packets across interconnected networks.\n  Transport Layer (equivalent to OSI\u0026rsquo;s Transport Layer): Ensures reliable end-to-end communication by handling data segmentation, flow control, and error recovery.\n  Application Layer (encompasses OSI\u0026rsquo;s Session, Presentation, and Application layers): Provides network services directly to end-users or applications.\n     Transmission Media #    Transmission Media refers to the physical pathways that transmit data in a network.\n  Types of transmission media:\n  Guided Media (Wired):\n Twisted Pair: Two insulated copper wires twisted together. Coaxial Cable: A central conductor surrounded by an insulating layer and a metallic shield. Fiber Optic Cable: Transmits data as light pulses through glass or plastic fibers.    Unguided Media (Wireless):\n Radio Waves: Wireless communication using radio frequency. Microwaves: High-frequency electromagnetic waves for long-distance communication. Infrared Waves: Short-range communication using infrared light.       Techniques for Bandwidth Utilization #   Line Configuration #    Line Configuration refers to the way two or more devices are connected in a communication channel.\n  Types of line configuration:\n  Point-to-Point: A direct link between two devices.\n  Multipoint (or Multidrop): Multiple devices share the same communication channel.\n     Multiplexing #   Frequency Division Multiplexing (FDM) #    FDM divides the frequency band of the channel into smaller sub-bands, with each sub-band dedicated to a different communication channel.\n  FDM is commonly used in radio and television broadcasting.\n   Time Division Multiplexing (TDM) #    TDM divides the time into fixed intervals, and each interval is allocated to different communication channels in a round-robin fashion.\n  TDM is widely used in digital communication systems.\n   Wave Division Multiplexing (WDM) #    WDM uses different wavelengths (colors) of light to transmit data simultaneously over optical fibers.\n  It is extensively used in high-capacity fiber-optic communication systems.\n   Asynchronous and Synchronous Transmission #    Asynchronous Transmission:\n Data is sent without a shared clock signal. Start and stop bits frame each character for synchronization.    Synchronous Transmission:\n Data is sent in blocks or frames with synchronization achieved through a shared clock signal. More efficient than asynchronous transmission for large amounts of data.     XDSL #    XDSL (Digital Subscriber Line) refers to a family of technologies that provide digital data transmission over the local telephone line.\n  Types of XDSL include ADSL (Asymmetric DSL), SDSL (\n  Symmetric DSL), and VDSL (Very High Bitrate DSL).\n Introduction to Wired and Wireless LAN #   Local Area Network (LAN):   A network that covers a small geographic area, like a single building or a campus.\n  Wired LAN: Uses physical cables (e.g., Ethernet) for communication.\n  Wireless LAN (WLAN):\n  Utilizes wireless communication technologies such as Wi-Fi.\n  Offers flexibility and mobility, allowing devices to connect without physical cables.\n      ","date":"9 November 2023","permalink":"/cn-chapter/cn-chapter-1/","section":"CN-chapters","summary":"Data Communication Components #   Representation of Data Communication #    Data communication involves the exchange of information between two or more devices using a communication medium.","title":"CN chapter-1"},{"content":"","date":"9 November 2023","permalink":"/cn-chapter/","section":"CN-chapters","summary":"","title":"CN-chapters"},{"content":" Program-1 : Network Command Explanation #   tcpdump #  tcpdump is a packet analyzer tool that allows you to capture and analyze network traffic. You can adjust the interface and packet count as needed for your specific use case.\n netstat #  netstat is a command-line utility for displaying network statistics, including open ports and active network connections. The command netstat -tuln shows listening TCP and UDP ports.\n ifconfig #  ifconfig is used to display and configure network interface parameters, including IP addresses, netmasks, and more. It provides information about the network interfaces on your system.\n nslookup #  nslookup is a network utility for performing DNS (Domain Name System) lookups. In the provided example, it performs a DNS lookup for \u0026lsquo;example.com\u0026rsquo;, returning information about the domain\u0026rsquo;s IP addresses.\n FTP #  FTP (File Transfer Protocol) is a network protocol used for transferring files between a client and a server. To interact with FTP programmatically, you should use dedicated FTP client libraries in C, as the command-line ftp client may not be suitable for automation.\n TELNET #  TELNET is a network protocol that allows terminal access to remote systems. To interact with TELNET servers programmatically, you\u0026rsquo;ll need to use a TELNET library or API, as it\u0026rsquo;s not straightforward to automate using a command-line program.\n traceroute #  traceroute is a network diagnostic tool used to trace the route that packets take from your computer to a destination host (e.g., \u0026lsquo;example.com\u0026rsquo;). It displays a list of intermediate routers and their response times.\nPlease note that some of these services/commands may require additional configuration, and some may not be available on all systems. The specific options and usage may vary depending on your operating system and network setup.\n// Program containing all commands in switch #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { int choice; while (1) { printf(\u0026#34;Select an option:\\n\u0026#34;); printf(\u0026#34;1. Run tcpdump\\n\u0026#34;); printf(\u0026#34;2. Run netstat\\n\u0026#34;); printf(\u0026#34;3. Run ifconfig\\n\u0026#34;); printf(\u0026#34;4. Run nslookup\\n\u0026#34;); printf(\u0026#34;5. Run FTP\\n\u0026#34;); printf(\u0026#34;6. Run TELNET\\n\u0026#34;); printf(\u0026#34;7. Run traceroute\\n\u0026#34;); printf(\u0026#34;8. Exit\\n\u0026#34;); printf(\u0026#34;Enter your choice: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); switch (choice) { case 1: system(\u0026#34;tcpdump -i eth0\u0026#34;); // Replace \u0026#39;eth0\u0026#39; with your network interface  break; case 2: system(\u0026#34;netstat -tuln\u0026#34;); break; case 3: system(\u0026#34;ifconfig\u0026#34;); break; case 4: printf(\u0026#34;Enter the hostname to look up: \u0026#34;); char hostname[256]; scanf(\u0026#34;%s\u0026#34;, hostname); char nslookupCommand[256]; sprintf(nslookupCommand, \u0026#34;nslookup %s\u0026#34;, hostname); system(nslookupCommand); break; case 5: system(\u0026#34;ftp\u0026#34;); // This will start an interactive FTP session  break; case 6: system(\u0026#34;telnet\u0026#34;); // This will start an interactive TELNET session  break; case 7: printf(\u0026#34;Enter the destination IP or hostname for traceroute: \u0026#34;); char dest[256]; scanf(\u0026#34;%s\u0026#34;, dest); char tracerouteCommand[256]; sprintf(tracerouteCommand, \u0026#34;traceroute %s\u0026#34;, dest); system(tracerouteCommand); break; case 8: exit(0); default: printf(\u0026#34;Invalid choice. Please try again.\\n\u0026#34;); } } return 0; } .\n","date":"6 November 2023","permalink":"/cn-chapter/cn-lab/","section":"CN-chapters","summary":"Program-1 : Network Command Explanation #   tcpdump #  tcpdump is a packet analyzer tool that allows you to capture and analyze network traffic.","title":"CN LAB"},{"content":" Things to Do After Installing a Debian-Based Distro #  Congratulations on installing your Debian-based Linux distribution! To make the most of your new operating system, here is a list of essential tasks to complete and things to consider after the installation.\n Update and Upgrade Your System #  Before you start customizing your system, it\u0026rsquo;s crucial to ensure your installation is up to date:\nOpen a terminal and run the following commands:\nsudo apt update sudo apt upgrade This will update your package list and upgrade all installed packages to their latest versions.\n Install Additional Software #    Package Management: Debian-based systems use APT (Advanced Package Tool) for package management. You can install software using the apt command. For example:\n To install a web browser (e.g., Firefox): sudo apt install firefox To install an office suite (e.g., LibreOffice): sudo apt install libreoffice    Software Center: Many Debian-based distributions come with a software center where you can easily browse and install software using a graphical interface.\n  Snap and Flatpak: Consider enabling Snap or Flatpak for access to additional software not available in the official repositories. You may need to install the Snap or Flatpak runtime.\n Snap: sudo apt install snapd Flatpak: Check your distribution\u0026rsquo;s documentation for installation instructions.     Configure System Repositories #  Ensure that your system is configured to access the appropriate repositories, including security updates and third-party sources if needed. Edit the /etc/apt/sources.list file or use a software source management tool, like software-properties-gtk (for Debian/Ubuntu systems).\nsudo software-properties-gtk  Install Proprietary Drivers #  If your system requires proprietary drivers for optimal hardware support, install them via the \u0026ldquo;Additional Drivers\u0026rdquo; utility or through the terminal. This may be necessary for graphics cards, Wi-Fi adapters, and more.\n Set Up User Accounts and Passwords #  Create additional user accounts for better security and isolation. To add a new user:\nsudo adduser newusername Make sure to add your user to the sudo group for administrative privileges:\nsudo usermod -aG sudo newusername Change passwords for the root user and your user account:\nsudo passwd root passwd yourusername  System Tweaks and Customization #    Desktop Environment: Customize your desktop environment according to your preferences. This may include changing wallpapers, themes, and settings.\n  Keyboard Shortcuts: Configure keyboard shortcuts for efficiency.\n  Display Settings: Adjust screen resolution, multiple monitor setup, and screen brightness.\n  Software Updates: Set up automatic software updates for security and system stability.\n  Firewall: Enable and configure the firewall (e.g., ufw or iptables) to enhance system security.\n  Time and Date: Set your time zone and synchronize your system clock with network time servers.\n  User Directories: Configure user directories, such as Downloads, Documents, and Pictures, for better organization.\n   Install Essential Software #  Install common Linux tools and utilities, including:\n Text editor (e.g., Vim or Nano) File manager (e.g., Nautilus, Dolphin) Terminal emulator (e.g., GNOME Terminal, Konsole) Archiving tool (e.g., File Roller, Ark) PDF reader (e.g., Evince, Okular) Image viewer (e.g., Eye of GNOME, Gwenview)   Optimize Power Saving for Wi-Fi #  To improve Wi-Fi speed and responsiveness, you can tweak power-saving settings:\n  Disable Wi-Fi Power Saving Mode: By default, Wi-Fi adapters often use power-saving features, which can reduce performance. To disable it temporarily (until the next reboot):\nsudo iwconfig wlan0 power off Replace wlan0 with the name of your Wi-Fi interface.\nTo disable it permanently, you can create a configuration file. Create a file in the /etc/network/if-up.d/ directory, such as /etc/network/if-up.d/wifi-power-off, with the following content:\n#!/bin/sh /sbin/iwconfig wlan0 power off Make it executable with:\nsudo chmod +x /etc/network/if-up.d/wifi-power-off   Tune Network Manager: If you are using NetworkManager, you can edit its configuration to control power management. Open the NetworkManager configuration file:\nsudo nano /etc/NetworkManager/conf.d/default-wifi-powersave-on.conf Change the value from 3 to 2 to disable Wi-Fi power-saving:\n[connection] wifi.powersave = 2 Save the file and restart NetworkManager:\nsudo service network-manager restart    Improve Security #    Firewall: Configure and enable a firewall (e.g., Uncomplicated Firewall, UFW) to control incoming and outgoing traffic.\n  Full Disk Encryption: If it\u0026rsquo;s not already enabled, consider setting up full-disk encryption (e.g., LUKS) to protect your data in case your device gets stolen.\n  ","date":"5 November 2023","permalink":"/posts/linux-setup/","section":"Posts","summary":"Things to Do After Installing a Debian-Based Distro #  Congratulations on installing your Debian-based Linux distribution!","title":"Debian based linux distro Setup"},{"content":"","date":"5 November 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" Problem Solving \u0026amp; Search #   Introduction to Intelligence #    Artificial Intelligence (AI) is a multidisciplinary field that seeks to create intelligent agents capable of emulating human-like behaviors such as problem-solving, learning, understanding natural language, and interacting with the environment.\n  AI encompasses a wide range of techniques and methodologies for building intelligent systems.\n   Foundations of Artificial Intelligence #    AI draws on several foundational components:\n  Machine Learning: Algorithms and models that enable machines to learn from data and improve their performance over time.\n  Knowledge Representation: Methods for storing, organizing, and reasoning with information in a way that machines can utilize.\n  Problem Solving: Developing algorithms to find solutions to complex problems.\n  Natural Language Processing (NLP): Techniques for understanding and generating human language.\n  Computer Vision: Enabling machines to interpret visual information from images or videos.\n    AI systems often combine these foundational elements to achieve intelligent behavior.\n   History of AI #   The history of AI can be divided into several key phases:   Early Foundations (1950s-1960s): The term \u0026ldquo;artificial intelligence\u0026rdquo; was first coined, and early AI programs were developed. This period was marked by optimism and high expectations.\n  AI Winter (1970s-1980s): Funding and interest in AI waned due to unrealistic expectations, limited computational power, and modest progress. Research slowed during this period.\n  Resurgence (late 20th century): Advances in machine learning, expert systems, and neural networks reignited interest in AI.\n  Contemporary AI (21st century): Recent progress in deep learning, reinforcement learning, and the availability of vast amounts of data have propelled AI into diverse applications, including self-driving cars, natural language processing, and more.\n     Structure of Agents #    In the context of AI, an agent is a system that perceives its environment through sensors and takes actions using actuators. Agents can range from simple to complex.\n  Key components of an agent include:\n  Sensors: These devices collect information from the environment. Sensors can include cameras, microphones, or other sensors specific to the agent\u0026rsquo;s function.\n  Actuators: These mechanisms execute actions in the environment, such as moving a robot\u0026rsquo;s wheels or generating text on a screen.\n  Knowledge Base: An internal storage system that retains information and knowledge necessary for decision-making.\n  Inference Engine: The component of the agent responsible for reasoning and making decisions based on the knowledge it possesses.\n     Problem Solving #   Formulating Problems #    In AI, problem-solving involves finding a sequence of actions that transforms an initial state into a goal state. This process is vital for tasks like planning and decision-making.\n  Problems are typically formulated with three main components:\n  Initial State: The starting configuration or situation.\n  Goal State: The desired outcome or target configuration.\n  Operators: Actions that can be applied to states, leading to state transitions.\n    The solution to a problem is a sequence of operators that, when applied to the initial state, results in the goal state.\n   Problem Types #   Problems in AI can be categorized based on various characteristics:   Deterministic: Problems where outcomes are entirely predictable and free from randomness. Chess is a deterministic game.\n  Nondeterministic: Problems with an element of randomness or uncertainty. Card games involve nondeterministic elements.\n  Sequential: Problems where the order of decisions and actions significantly impacts future states. Chess is an example of a sequential game.\n  Adversarial: Competitive problems where two or more agents have conflicting goals. Games like chess and tic-tac-toe are adversarial problems.\n     States and Operators #    In problem-solving, a state represents a particular configuration or situation within the problem space. It is a snapshot of the problem at a specific point in time.\n  Operators are actions that can be applied to states, leading to state transitions. These operators define the legal moves or transformations in the problem space.\n  For instance, in the 8-Puzzle problem, states are different configurations of the puzzle board, and operators are the actions of moving a tile to an adjacent empty space.\n   State Space #    The state space of a problem comprises all possible states that can be reached from the initial state by applying operators. It represents the entire landscape of the problem.\n  State spaces can vary in size and complexity. For some problems, exploring the entire state space may be computationally infeasible.\n   Search Strategies #   Search strategies are algorithms used to explore the state space and find solutions to problems. Common search strategies include:   Breadth-First Search (BFS): BFS explores all neighbors of a state before moving deeper into the state space. It is guaranteed to find the shortest path to the goal if the state space is finite and unweighted.\n  Depth-First Search (DFS): DFS explores as far as possible along one branch of the state space tree before backtracking. It is often used when memory is limited, and it may not necessarily find the shortest path.\n  Uniform Cost Search: This strategy expands nodes with the lowest path cost, making it suitable for problems where different operators have different costs.\n     Breadth-First Search (BFS) Algorithm #  Breadth-First Search explores the state space level by level, expanding all nodes at a given level before moving to the next level. It is implemented using a queue data structure.\n# Pseudocode for Breadth-First Search function BFS(initial_state, goal_state): initialize an empty queue enqueue initial_state while the queue is not empty: current_state = dequeue from the queue if current_state is the goal_state: return solution path for each successor_state of current_state: if successor_state has not been visited: enqueue successor_state mark successor_state as visited return no solution found  Depth-First Search (DFS) Algorithm #  Depth-First Search explores the state space by traversing as deeply as possible along a branch before backtracking. It is implemented using a stack or recursion.\n# Pseudocode for Depth-First Search function DFS(current_state, goal_state): if current_state is the goal_state: return solution path for each successor_state of current_state: if successor_state has not been visited: result = DFS(successor_state, goal_state) if result is a solution path: return result return no solution found  Informed Search Strategies #    Informed search strategies use domain-specific knowledge to guide the search more efficiently. These strategies are especially valuable when the state space is large.\n  Best-First Search: This algorithm selects the node that is closest to the goal state based on an evaluation function. The evaluation function is typically a heuristic that estimates the cost from the current state to the goal.\n  A Algorithm*: A* combines the cost of the path from the initial state with a heuristic that estimates the cost\n  from the current state to the goal. It uses the sum of these two values to guide the search. A* is optimal and complete if the heuristic is admissible and consistent.\n Heuristic Functions #    A heuristic function provides an estimate of the cost from a given state to the goal state. It is crucial for informed search algorithms such as A*.\n  A heuristic function should have two essential properties:\n  Admissibility: It should never overestimate the true cost to reach the goal from the current state. If a heuristic is admissible, A* is guaranteed to find the optimal solution.\n  Consistency: The heuristic should satisfy the triangle inequality, ensuring that it provides meaningful guidance during the search.\n    Example of a heuristic for the 8-Puzzle problem: The number of misplaced tiles is a simple heuristic. It counts the number of tiles in the current state that are not in their correct positions. This heuristic is admissible but not always consistent.\n  # Example Heuristic for 8-Puzzle: Number of misplaced tiles def heuristic(state, goal): count = 0 for i in range(len(state)): if state[i] != goal[i]: count += 1 return count  Iterative Deepening A* (IDA*) #    Iterative Deepening A* (IDA*) is an advanced search algorithm that combines the principles of A* with depth-first search. It is often used when memory is limited, but a near-optimal solution is required.\n  The algorithm starts with a shallow depth limit and gradually increases it with each iteration until it finds a solution.\n  IDA* uses the A* heuristic and is designed to find the optimal solution when a consistent heuristic is used.\n   Adversarial Search/Game Playing #   Perfect Decision Game #    In a perfect decision game, both players have complete knowledge of the game and can see the entire game tree. They make optimal decisions to maximize their chances of winning.\n  The classic algorithm for perfect information games is the Minimax Algorithm.\n   Minimax Algorithm #    The Minimax Algorithm is a decision-making algorithm used in perfect decision games like chess and tic-tac-toe.\n  It operates on the principle of minimizing the possible loss for a worst-case scenario. In the context of game playing, it means that each player assumes that their opponent makes optimal moves to maximize their own outcome.\n  The algorithm is based on a tree structure, with nodes representing game states and edges representing possible moves.\n  # Pseudocode for Minimax Algorithm function minimax(node, depth, maximizingPlayer): if depth is 0 or node is a terminal node: return the heuristic value of node if maximizingPlayer: bestValue = -∞ for child in node\u0026#39;s children: value = minimax(child, depth - 1, False) bestValue = max(bestValue, value) return bestValue else: bestValue = +∞ for child in node\u0026#39;s children: value = minimax(child, depth - 1, True) bestValue = min(bestValue, value) return bestValue  Imperfect Decision Game #    In an imperfect decision game, not all information is available to the players. There may be hidden information, uncertainty, or randomness involved.\n  Alpha-Beta Pruning is a critical optimization technique to improve the efficiency of the Minimax Algorithm in these games.\n   Alpha-Beta Pruning #    Alpha-Beta Pruning is a search algorithm enhancement that reduces the number of nodes evaluated in the Minimax Algorithm.\n  It uses two values, alpha and beta, to keep track of the best values found so far for the maximizing and minimizing players, respectively.\n  Alpha represents the best value found for the maximizing player, and beta represents the best value for the minimizing player.\n  The algorithm prunes branches of the search tree that cannot lead to better results. If alpha becomes greater than or equal to beta, a branch can be safely pruned.\n  # Pseudocode for Alpha-Beta Pruning function alpha_beta(node, depth, alpha, beta, maximizingPlayer): if depth is 0 or node is a terminal node: return the heuristic value of node if maximizingPlayer: for child in node\u0026#39;s children: alpha = max(alpha, alpha_beta(child, depth - 1, alpha, beta, False)) if beta ≤ alpha: break return alpha else: for child in node\u0026#39;s children: beta = min(beta, alpha_beta(child, depth - 1, alpha, beta, True)) if beta ≤ alpha: break return beta ","date":"5 November 2023","permalink":"/ai-chapter/ai-chapter-1/","section":"AI-chapters","summary":"Problem Solving \u0026amp; Search #   Introduction to Intelligence #    Artificial Intelligence (AI) is a multidisciplinary field that seeks to create intelligent agents capable of emulating human-like behaviors such as problem-solving, learning, understanding natural language, and interacting with the environment.","title":"AI chapter-1"},{"content":" AI lab #   Week-1(from list) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week1_listset.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; list=[1,2,\u0026#34;shoaib\u0026#34;,4,5] print(list) list1=[1,2,3,4] list2=list1+[\u0026#34;programming\u0026#34;] print(list2) list1.insert(2 ,9) print(list1) list1=[1,2,3] list1.append(678) print(list1) list1=[1,2,3] list1.extend([65,99.7]) print(list1) list=[1,2,3,4,\u0026#34;python\u0026#34;] list[4]=\u0026#34;shoaib\u0026#34; print(list) del(list[2]) print(list) list=[7,3,9,1,8] list.sort() print(list) list.reverse() print(list) print(len(list)) print(sum(list)) print(min(list)) print(max(list)) print(9 in list) #tuples tup=(1,4,7,8) print(tup) tup=(\u0026#34;shoaib\u0026#34;,4,5,6) print(tup) tup=(\u0026#34;shoaib\u0026#34;,4,5,6) tup_new=tup+(\u0026#34;asim\u0026#34;,17) print(tup_new) print(tup[0]) print(tup[1]) x=(1,(\u0026#34;shoaib\u0026#34;,\u0026#34;asim\u0026#34;)) print(x[1][1]) print(x[0]) x=(1,(\u0026#34;shoaib\u0026#34;,\u0026#34;asim\u0026#34;),(\u0026#34;python\u0026#34;,\u0026#34;master\u0026#34;)) print(x[2,1]) print(x[2][1]) print(x[2][0]) #nested list x=[1, (\u0026#34;shoaib\u0026#34;),(\u0026#34;asim\u0026#34;)] print(x[1][1]) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:1000,\u0026#34;india\u0026#34;:2220} print(d) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;shoaib\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;asim\u0026#34;)} print(d) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;shoaib\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;asim\u0026#34;)} print(d[\u0026#34;uk\u0026#34;]) d={\u0026#34;usa\u0026#34;:100,\u0026#34;uk\u0026#34;:[200,\u0026#34;shoaib\u0026#34;],\u0026#34;india\u0026#34;:(300,\u0026#34;asim\u0026#34;)} del(d[\u0026#34;usa\u0026#34;]) print(d) #sets set={\u0026#39;shoaib\u0026#39;,\u0026#39;asim\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;} print(set) set={\u0026#39;shoaib\u0026#39;,\u0026#39;asim\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;,\u0026#39;asim\u0026#39;} print(set) set={\u0026#39;shoaib\u0026#39;,\u0026#39;asim\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;science\u0026#39;} print(set.add(\u0026#39;add\u0026#39;)) set.add(\u0026#39;add\u0026#39;) print(set) set.remove(\u0026#39;add\u0026#39;) print(set) print(len(set)) s1={1,2,4,5,6} s2={1,2,3,7,9} print(s1\u0026amp;s2) print(s1.intersection(s2)) print(s1|s2) print(s1.union(s2)) def my_add(a): b=a+2 return b print(my_add(4))  Week-2 #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week2bfs_s_q.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; stack=[] stack.append(\u0026#39;a\u0026#39;) stack.append(\u0026#39;b\u0026#39;) stack.append(\u0026#39;c\u0026#39;) print(stack) print(stack.pop()) print(stack.pop()) print(stack) print(stack.pop()) print(stack.pop()) print(stack.pop()) queue=[] print() queue.append(\u0026#39;a\u0026#39;) queue.append(\u0026#39;b\u0026#39;) queue.append(\u0026#39;c\u0026#39;) print(\u0026#34;initial queue\u0026#34;) print(queue) print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) from queue import PrioriyQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) print(q.get()) print(q) print(q.get()) from queue import PriorityQueue q=PriorityQueue q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) from queue import PriorityQueue q=PriorityQueue q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.get()) from queue import PriorityQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.get()) print(q.get()) print(\u0026#39;item in queue\u0026#39;,q.qsize()) print(q.empty()) print(q.full()) print(q.qsize()) print(q.get()) from queue import PriorityQueue q=PriorityQueue() q.put((2,\u0026#39;g\u0026#39;)) q.put((3,\u0026#39;e\u0026#39;)) q.put((4,\u0026#39;k\u0026#39;)) q.put((5,\u0026#39;s\u0026#39;)) q.put((1,\u0026#39;e\u0026#39;)) print(\u0026#39;item in queue\u0026#39;,q.qsize()) # Commented out IPython magic to ensure Python compatibility. #tree # %pip install treelib from treelib import Tree tree = Tree() tree.create_node(\u0026#39;shoaib\u0026#39;,\u0026#39;Shoaib\u0026#39;)#root node tree.create_node(\u0026#39;jane\u0026#39;,\u0026#39;Jane\u0026#39;,parent=\u0026#39;Shoaib\u0026#39;) tree.show() print(tree) from treelib import Tree tree=Tree() tree.create_node(1,\u0026#39;shoaib\u0026#39;) tree.create_node(2,2,parent=\u0026#39;shoaib\u0026#39;) tree.create_node(3,3,parent=\u0026#39;shoaib\u0026#39;) tree.create_node(4,4,parent=2) tree.create_node(5,5,parent=3) tree.show() print(tree) #bfs graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } def bfs(graph,initial): visited=[] queue=[initial] while queue: node=queue.pop(0) if node not in visited: visited.append(node) neighbours = graph[node] for neighbour in neighbours: queue.append(neighbour) return visited print(bfs(graph,\u0026#39;3\u0026#39;)) #bfs undirected graph graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;2\u0026#39;:[\u0026#39;3\u0026#39;], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;,\u0026#39;3\u0026#39;], \u0026#39;8\u0026#39;:[\u0026#39;7\u0026#39;] } def bfs(graph,initial): visited=[] queue=[initial] while queue: node=queue.pop(0) if node not in visited: visited.append(node) neighbours = graph[node] for neighbour in neighbours: queue.append(neighbour) return visited print(bfs(graph,\u0026#39;3\u0026#39;))  Week-3 #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;Untitled10.ipynb Automatically generated by Colaboratory. \u0026#34;\u0026#34;\u0026#34; graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } visited = set() # to keep track of nodes def dfs(visited,graph,node): if node not in visited: print(node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour) #driver code print(\u0026#34;dfs\u0026#34;) dfs(visited,graph,\u0026#39;5\u0026#39;) graph={ \u0026#39;5\u0026#39;:[\u0026#39;3\u0026#39;,\u0026#39;7\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;2\u0026#39;:[], \u0026#39;4\u0026#39;:[\u0026#39;8\u0026#39;], \u0026#39;8\u0026#39;:[] } visited = set() # to keep track of nodes def dfs(visited,graph,node): if node not in visited: print(node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour) #driver code print(\u0026#34;dfs\u0026#34;) dfs(visited,graph,\u0026#39;3\u0026#39;) from queue import PriorityQueue v = 14 graph = [[] for i in range(v)] # Function For Implementing Best First Search # Gives output path having lowest cost def best_first_search(actual_Src, target, n): visited = [False] * n pq = PriorityQueue() pq.put((0, actual_Src)) visited[actual_Src] = True while pq.empty() == False: u = pq.get()[1] # Displaying the path having lowest cost print(u, end=\u0026#34; \u0026#34;) if u == target: break for v, c in graph[u]: if visited[v] == False: visited[v] = True pq.put((c, v)) print() # Function for adding edges to graph def addedge(x, y, cost): graph[x].append((y, cost)) graph[y].append((x, cost)) # The nodes shown in above example(by alphabets) are # implemented using integers addedge(x,y,cost); addedge(0, 1, 3) addedge(0, 2, 6) addedge(0, 3, 5) addedge(1, 4, 9) addedge(1, 5, 8) addedge(2, 6, 12) addedge(2, 7, 14) addedge(3, 8, 7) addedge(8, 9, 5) addedge(8, 10, 6) addedge(9, 11, 1) addedge(9, 12, 10) addedge(9, 13, 2) source = 0 target = 9 best_first_search(source, target, v) ","date":"5 November 2023","permalink":"/ai-chapter/ai-lab/","section":"AI-chapters","summary":"AI lab #   Week-1(from list) #  # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34;week1_listset.","title":"AI lab"},{"content":"","date":"5 November 2023","permalink":"/ai-chapter/","section":"AI-chapters","summary":"","title":"AI-chapters"},{"content":" R Programming Language #   Introduction #  R is a robust programming language and environment designed for statistical computing and data analysis. Developed by Ross Ihaka and Robert Gentleman at the University of Auckland, it has evolved into a versatile tool for professionals in various fields, including statistics, data science, and academia.\n Basics #   R Basics #   Assigning Values #  Use the \u0026lt;- operator to assign values to variables:\nx \u0026lt;- 10  Data Types #  R supports various data types, including numeric, character, logical, and factors.\n Vectors #  Create a numeric vector:\nnumeric_vector \u0026lt;- c(1, 2, 3, 4, 5)  Matrices #  Generate a matrix:\nmatrix_data \u0026lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3)  Data Frames #  Build a data frame:\ndata_frame \u0026lt;- data.frame(Name = c(\u0026#34;John\u0026#34;, \u0026#34;Jane\u0026#34;), Age = c(25, 30))  Basic Operations #   Addition of Two Numbers #  a \u0026lt;- 5 b \u0026lt;- 7 sum_result \u0026lt;- a + b  Subtraction of Two Numbers #  difference_result \u0026lt;- a - b  Multiplication of Two Numbers #  product_result \u0026lt;- a * b  Division of Two Numbers #  quotient_result \u0026lt;- a / b  Data Manipulation #   Data Import/Export #   Reading CSV #  Read data from a CSV file:\ndata \u0026lt;- read.csv(\u0026#34;filename.csv\u0026#34;)  Writing CSV #  Write data to a CSV file:\nwrite.csv(data, \u0026#34;output.csv\u0026#34;)  Data Exploration #   Summary Statistics #  Get summary statistics of a data frame:\nsummary(data)  Head and Tail #  View the first or last few rows of a data frame:\nhead(data) tail(data)  Data Manipulation #   Subset Data #  Subset data based on a condition:\nsubset_data \u0026lt;- data[data$Age \u0026gt; 25, ]  Filter Data (dplyr package) #  Filter data using the dplyr package:\nlibrary(dplyr) filtered_data \u0026lt;- filter(data, Age \u0026gt; 25)  Statistical Analysis #   Descriptive Statistics #   Mean #  Calculate the mean of a variable:\nmean(data$variable)  Median #  Calculate the median of a variable:\nmedian(data$variable)  Hypothesis Testing #   t-test #  Perform a t-test between two groups:\nt.test(variable ~ group, data = data)  ANOVA #  Perform ANOVA:\nanova_model \u0026lt;- aov(variable ~ group, data = data) summary(anova_model)  Data Visualization #   Base Plotting #   Scatter Plot #  Create a scatter plot using base plotting:\nplot(data$X, data$Y, main = \u0026#34;Scatter Plot\u0026#34;, xlab = \u0026#34;X-axis\u0026#34;, ylab = \u0026#34;Y-axis\u0026#34;)  Histogram #  Create a histogram using base plotting:\nhist(data$variable, main = \u0026#34;Histogram\u0026#34;, xlab = \u0026#34;Value\u0026#34;, col = \u0026#34;lightblue\u0026#34;)  ggplot2 #   Scatter Plot #  Create a scatter plot using the ggplot2 package:\nlibrary(ggplot2) ggplot(data, aes(x = X, y = Y)) + geom_point() + labs(title = \u0026#34;Scatter Plot\u0026#34;, x = \u0026#34;X-axis\u0026#34;, y = \u0026#34;Y-axis\u0026#34;)  Boxplot #  Create a boxplot using the ggplot2 package:\nggplot(data, aes(x = group, y = variable)) + geom_boxplot() + labs(title = \u0026#34;Boxplot\u0026#34;, x = \u0026#34;Group\u0026#34;, y = \u0026#34;Variable\u0026#34;) ","date":"5 November 2023","permalink":"/ds-chapter/basic-r/","section":"DS-chapters","summary":"R Programming Language #   Introduction #  R is a robust programming language and environment designed for statistical computing and data analysis.","title":"Basic R"},{"content":"  Data Science #   Introduction to Data Science #   Definition #  Data Science is an interdisciplinary field that leverages scientific methods, processes, algorithms, and systems to extract insights and knowledge from structured and unstructured data.\n Significance #   Informed Decision Making: Data Science enables organizations to make informed decisions based on data-driven insights. Predictive Analysis: It allows for the prediction of future trends and outcomes. Pattern Recognition: Identifying patterns and correlations within data for a deeper understanding. Optimizing Processes: Improves efficiency and effectiveness by optimizing processes through data analysis. Competitive Advantage: Provides a competitive edge by uncovering hidden opportunities and risks.   Linear Algebra for Data Science #   Scalars, Vectors, Matrices, and Tensors #   Scalars: Single numerical values. Vectors: Ordered arrays of numbers. Matrices: 2D arrays of numbers. Tensors: Generalization of scalars, vectors, and matrices to higher dimensions.   Operations in Linear Algebra #   Scalar Multiplication and Addition: Multiply or add a scalar to a matrix. Matrix Multiplication: Dot product of matrices. Transpose: Swapping rows and columns of a matrix.   Problem 1: #  Perform scalar multiplication on the matrix \\(A = \\begin{bmatrix} 2 \u0026amp; 3 \\ 4 \u0026amp; 1 \\end{bmatrix}\\) with the scalar \\(k = 3\\).\nSolution: \\[ kA = \\begin{bmatrix} 6 \u0026amp; 9 \\ 12 \u0026amp; 3 \\end{bmatrix} \\]\n Problem 2: #  Given matrices \\(B = \\begin{bmatrix} 1 \u0026amp; -2 \\ 3 \u0026amp; 0 \\end{bmatrix}\\) and \\(C = \\begin{bmatrix} 4 \u0026amp; 1 \\ -1 \u0026amp; 2 \\end{bmatrix}\\), calculate the product \\(BC\\).\nSolution: \\[ BC = \\begin{bmatrix} 3 \u0026amp; 0 \\ 11 \u0026amp; 2 \\end{bmatrix} \\]\n Linear Equations #   Definition #  A linear equation is an algebraic equation in which each term is either a constant or the product of a constant and a variable.\n Standard Form #  \\[ a_1x_1 + a_2x_2 + \\ldots + a_nx_n = b \\]\n Solving Linear Equations #   Substitution Method: Solve one equation for one variable and substitute into the other. Elimination Method: Eliminate one variable by adding or subtracting equations. Matrix Method: Represent the system of equations as a matrix and solve.   Problem 3: #  Solve the system of equations: \\[ 2x + y = 8 \\] \\[ 3x - 2y = 1 \\]\nSolution: Multiplying the first equation by 2 and adding the second equation, we get \\(7x = 9\\), leading to \\(x = \\frac{9}{7}\\). Substituting \\(x\\) back, we find \\(y = \\frac{5}{7}\\).\n Problem 4: #  Express the following linear equation in standard form: \\[ 4x - 2y + 6z = 10 \\]\nSolution: Rearranging the given equation, we get: [ 4x - 2y + 6z - 10 = 0 \\]\n Distance #   Euclidean Distance #  \\[ d(x, y) = \\sqrt{\\sum_{i=1}^{n}(x_i - y_i)^2} \\]\n Manhattan Distance (L1 Norm) #  \\[ d(x, y) = \\sum_{i=1}^{n}|x_i - y_i| \\]\n Minkowski Distance #  \\[ d(x, y) = \\left(\\sum_{i=1}^{n}|x_i - y_i|^p\\right)^{\\frac{1}{p}} \\]\n Problem 5: #  Calculate the Euclidean distance between points \\(P(2, 5)\\) and \\(Q(7, 1)\\).\nSolution: \\[ d(P, Q) = \\sqrt{(7-2)^2 + (1-5)^2} = \\sqrt{25 + 16} = \\sqrt{41} \\]\n Problem 6: #  Determine the Manhattan distance between vectors \\(V = [2, -3, 5]\\) and \\(W = [1, 4, -2]\\).\nSolution: \\[ d(V, W) = |2-1| + |-3-4| + |5-(-2)| = 1 + 7 + 7 = 15 \\]\n Eigenvalues and Eigenvectors #   Definition #   Eigenvalues ((\\lambda)): Scalar values that represent how a linear transformation changes. Eigenvectors ((v)): Vectors that remain unchanged in direction after a linear transformation.   Calculation #  \\[ Av = \\lambda v \\] where \\(A\\) is a square matrix.\n Problem 7: #  Given a matrix \\(D = \\begin{bmatrix} 3 \u0026amp; 1 \\ 1 \u0026amp; 2 \\end{bmatrix}\\), find its eigenvalues and corresponding eigenvectors.\nSolution: The characteristic equation leads to \\(\\lambda^2 - 5\\lambda + 5 = 0\\), with solutions \\(\\lambda_1 = 1\\) and \\(\\lambda_2 = 4\\).\nFor \\(\\lambda_1 = 1\\), solving \\( (D - I)v = 0\\) gives \\(v_1 = \\begin{bmatrix} -1 \\ 1 \\end{bmatrix}\\).\nFor \\(\\lambda_2 = 4\\), solving \\( (D - 4I)v = 0\\) gives \\(v_2 = \\begin{bmatrix} 1 \\ 1 \\end{bmatrix}\\).\n Dimensionality Reduction #   Motivation #   Curse of Dimensionality: Increasing dimensions may lead to sparsity and computational challenges. Feature Selection and Extraction: Retain important information while reducing dimensionality.   Techniques #   Principal Component Analysis (PCA): Linear transformation to convert data into a new coordinate system. t-Distributed Stochastic Neighbor Embedding (t-SNE): Non-linear technique for visualizing high-dimensional data.   Problem 8: #  Apply PCA to reduce the dimensionality of a dataset with 4 features to 2 dimensions.\nSolution:\n Compute Covariance Matrix: Calculate the covariance matrix of the dataset. Find Eigenvectors and Eigenvalues: Find the eigenvectors and eigenvalues of the covariance matrix. Sort Eigenvectors by Eigenvalues: Sort the eigenvectors based on their corresponding eigenvalues. Select Top (k) Eigenvectors: Choose the top (k) eigenvectors to form the transformation matrix. Transform Data: Multiply the original data by the transformation matrix to obtain the reduced-dimensional data.   t-Distributed Stochastic Neighbor Embedding (t-SNE) #   Problem #  9: Explain the motivation behind using t-SNE for dimensionality reduction and provide a step-by-step overview of the t-SNE algorithm.\nSolution: t-SNE is motivated by the need to visualize high-dimensional data in a lower-dimensional space while preserving local relationships. Here\u0026rsquo;s a step-by-step overview:\n Define Pairwise Similarities: Compute pairwise similarities between data points in the high-dimensional space using a Gaussian distribution. Define Pairwise Similarities in Low-Dimensional Space: Compute pairwise similarities in the low-dimensional space using a Student\u0026rsquo;s t-distribution. Optimization: Minimize the difference between the pairwise similarities in the high-dimensional and low-dimensional spaces using gradient descent. Visualization: Map the data points to the lower-dimensional space for visualization.   ","date":"5 November 2023","permalink":"/ds-chapter/ds-chapter-1/","section":"DS-chapters","summary":"Data Science #   Introduction to Data Science #   Definition #  Data Science is an interdisciplinary field that leverages scientific methods, processes, algorithms, and systems to extract insights and knowledge from structured and unstructured data.","title":"DS chapter-1"},{"content":"","date":"5 November 2023","permalink":"/ds-chapter/","section":"DS-chapters","summary":"","title":"DS-chapters"},{"content":" Detailed explanation of commonly used Git commands #   Configuration #   Configure User Information #  Set your name and email address that will be associated with your Git commits:\ngit config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;youremail@example.com\u0026#34;  git config is used to set configuration options in Git. --global flag sets the configuration globally for your user.   Creating a Repository #   Initialize a New Repository #  Create a new Git repository in the current directory:\ngit init  git init initializes a new Git repository in the current directory, creating a .git subdirectory that stores Git configuration and version history.   Making Changes #   Add Changes to Staging #  Add modified files to the staging area, preparing them for the next commit:\ngit add \u0026lt;file\u0026gt;  git add stages changes for the next commit. You can specify individual files or directories.   Commit Changes #  Create a commit with staged changes:\ngit commit -m \u0026#34;Your commit message\u0026#34;  git commit creates a new commit with the changes that are in the staging area. The -m flag is used to provide a commit message that briefly describes the changes.   Viewing Status and History #   Check Status #  View the status of your working directory:\ngit status  git status provides information about changes in your working directory and the staging area.   View Commit History #  Display commit history:\ngit log  git log shows a chronological list of commits in the repository, including commit messages, authors, and commit hashes.   Branching and Merging #   Create a New Branch #  Create a new branch based on the current branch:\ngit branch \u0026lt;branchname\u0026gt;  git branch is used to create a new branch. Specify the branch name to create a new branch.   Switch Branch #  Switch to a different branch:\ngit checkout \u0026lt;branchname\u0026gt;  git checkout allows you to switch between branches. Specify the branch name to switch to that branch.   Merge Branch #  Merge changes from one branch into the current branch:\ngit merge \u0026lt;branchname\u0026gt;  git merge combines changes from the specified branch into the current branch, creating a new commit with the merged changes.   Delete Branch #  Delete a branch:\ngit branch -d \u0026lt;branchname\u0026gt;  git branch -d is used to delete a branch that is no longer needed. Use -d to delete a branch if it has been fully merged into other branches.   Remote Repositories #   Add a Remote #  Add a remote repository to your Git configuration:\ngit remote add origin \u0026lt;remote-url\u0026gt;  git remote is used to manage remote repositories. add specifies that you want to add a remote. origin is the commonly used name for the remote, but you can choose a different name. \u0026lt;remote-url\u0026gt; is the URL of the remote repository.   Fetch Changes #  Fetch changes from a remote repository:\ngit fetch  git fetch downloads objects and references from another repository, updating your remote-tracking branches without modifying your working directory.   Push Changes #  Push local changes to a remote repository:\ngit push origin \u0026lt;branchname\u0026gt;  git push sends your local changes to a remote repository. origin is the name of the remote repository. \u0026lt;branchname\u0026gt; specifies the branch you want to push.   Pull Changes #  Pull changes from a remote repository and merge them into your local branch:\ngit pull  git pull combines git fetch and git merge to update your local branch with changes from a remote repository.   Collaborating #   Clone a Repository #  Clone a remote repository to your local machine:\ngit clone \u0026lt;repository-url\u0026gt;  git clone creates a local copy of a remote repository on your computer.   Fork a Repository #  Fork a repository on a platform like GitHub to create your own copy. This is not a Git command but a common step when contributing to open-source projects.\n Create a Pull Request #  Create a pull request to propose changes to the original repository. This is done on platforms like GitHub and GitLab, not through Git commands.\n Review and Merge #  Review pull requests and merge changes in a collaborative environment. This also happens on platforms like GitHub and GitLab, not through Git commands.\n Miscellaneous #   Ignore Files #  Create a .gitignore file to specify which files or directories should be ignored by Git. You can list file patterns, directories, or file extensions that Git should not track.\n View Differences #  View the differences between files in your working directory and the most recent commit:\ngit diff  git diff shows the differences between your working directory and the last committed state.   Help #  Get help on a specific Git command:\ngit --help \u0026lt;command\u0026gt;  Use git --help followed by the command name to get detailed information about a specific Git command.  This detailed explanation covers commonly used Git commands for version control. For more in-depth documentation, you can refer to the Git documentation\n","date":"5 November 2023","permalink":"/posts/git-guide/","section":"Posts","summary":"Detailed explanation of commonly used Git commands #   Configuration #   Configure User Information #  Set your name and email address that will be associated with your Git commits:","title":"Git Guide"},{"content":" Basic vim setup #   [!NOTE] Note Paste the below code in vimrc file\n syntax onfiletype plugin indent onset modelines=0set numberset rulerset visualbellset encoding=utf-8set wrapset textwidth=79set formatoptions=tcqrn1set tabstop=2set shiftwidth=2set softtabstop=2set expandtabset noshiftround\u0026#34; Cursor motionset scrolloff=3set backspace=indent,eol,startset matchpairs+=\u0026lt;:\u0026gt;runtime! macros/matchit.vimnnoremap j gjnnoremap k gkset hiddenset ttyfast\u0026#34; Status barset laststatus=2\u0026#34; Last lineset showmodeset showcmd\u0026#34; Searchingnnoremap / /\\vvnoremap / /\\vset hlsearchset incsearchset ignorecaseset smartcaseset showmatchmap \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt; :let @/=\u0026#39;\u0026#39;\u0026lt;cr\u0026gt; \u0026#34; clear search\u0026#34; Visualize tabs and newlinesset listchars=tab:▸\\ ,eol:¬\u0026#34; Uncomment this to enable by default:\u0026#34; set list \u0026#34; To enable by default\u0026#34; Or use your leader key + l to toggle on/offmap \u0026lt;leader\u0026gt;l :set list!\u0026lt;CR\u0026gt; \u0026#34; Toggle tabs and EOL Here is the complete breakdown: #  syntax on syntax on enables syntax highlighting in Vim. This highlights different elements of your code with different colors to make it more readable and easier to understand.  filetype plugin indent on filetype plugin indent on enables file type detection, which allows Vim to automatically detect the type of file you are editing and apply appropriate settings and plugins for that file type. It also enables automatic indentation based on the file type.  set modelines=0 set modelines=0 disables the reading of modelines. Modelines are special comments in a file that can be used to specify settings for that file. Setting this to 0 means Vim won\u0026rsquo;t read and apply settings from modelines.  set number set number displays line numbers on the left side of the editor, making it easier to reference specific lines in the file.  set ruler set ruler displays the current line and column number in the status line at the bottom of the Vim window.  set visualbell set visualbell replaces the audible bell with a visual bell. When an error or warning occurs, Vim will flash the screen instead of producing a sound.  set encoding=utf-8 set encoding=utf-8 sets the character encoding to UTF-8, which is a widely used encoding for handling a wide range of characters from different languages.  set wrap set wrap enables line wrapping, causing long lines to wrap to the next line if they exceed the screen width.  set textwidth=79 set textwidth=79 sets the maximum line width to 79 characters. This can be useful for ensuring that your code conforms to a specific line length limit.  set formatoptions=tcqrn1 set formatoptions=tcqrn1 sets various formatting options for auto-indentation and text formatting. These options control how Vim formats text as you type.  set tabstop=2set shiftwidth=2set softtabstop=2set expandtabset noshiftround These lines configure indentation settings. They set the tab width to 2 spaces, the number of spaces to use for each level of indentation, and configure tabs to be expanded as spaces.  \u0026#34; Cursor motionset scrolloff=3 set scrolloff=3 configures Vim to keep at least 3 lines of context when scrolling up or down. This helps maintain context while navigating through the file.  set backspace=indent,eol,start set backspace=indent,eol,start allows you to use the Backspace key to delete characters beyond the current indent, at the end of a line, and at the start of insert mode.  set matchpairs+=\u0026lt;:\u0026gt;runtime! macros/matchit.vim These lines configure matching pairs for brackets (\u0026lt;:\u0026gt;). It also loads the matchit.vim plugin, which enhances Vim\u0026rsquo;s ability to jump between matching pairs of characters using the % key.  nnoremap j gjnnoremap k gk These lines create non-recursive key mappings for j and k to make them move by display lines (gj and gk) instead of actual lines. This can be useful when working with wrapped lines.  set hidden set hidden allows you to switch between buffers without saving changes. Unsaved changes are preserved in the background.  set ttyfast set ttyfast optimizes Vim for faster terminal response.  \u0026#34; Status barset laststatus=2 set laststatus=2 ensures that the status bar is always displayed with at least two lines.  \u0026#34; Last lineset showmodeset showcmd These lines enable the display of the current mode (e.g., Normal, Insert) and show partial command input at the bottom of the screen.  \u0026#34; Searchingnnoremap / /\\vvnoremap / /\\vset hlsearchset incsearchset ignorecaseset smartcaseset showmatchmap \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt; :let @/=\u0026#39;\u0026#39;\u0026lt;cr\u0026gt; \u0026#34; clear search These lines configure various aspects of searching and search highlighting in Vim. They also create key mappings for search-related commands and provide a mapping to clear the search pattern using \u0026lt;leader\u0026gt;\u0026lt;space\u0026gt;.  \u0026#34; Visualize tabs and newlinesset listchars=tab:▸\\ ,eol:¬\u0026#34; Uncomment this to enable by default:\u0026#34; set list \u0026#34; To enable by default\u0026#34; Or use your leader key + l to toggle on/offmap \u0026lt;leader\u0026gt;l :set list!\u0026lt;CR\u0026gt; \u0026#34; Toggle tabs and EOL These lines configure how tabs and newlines are visualized. They use special characters to represent tabs (▸) and end-of-line characters (¬). Additionally, there\u0026rsquo;s a key mapping to toggle the visualization of tabs and EOL characters using \u0026lt;leader\u0026gt;l.  This .vimrc file provides various settings and key mappings to enhance your Vim experience. You can customize it further to suit your preferences.\n","date":"5 November 2023","permalink":"/posts/vim-setup/","section":"Posts","summary":"Basic vim setup #   [!","title":"Vim Setup for Competitive Programming"},{"content":" Knowledge, Reasoning \u0026amp; Planning #   Reasoning #   Knowledge-Based Agent #    A knowledge-based agent is a sophisticated system designed to utilize knowledge for decision-making and problem-solving.\n  Components:\n  Knowledge Base (KB): A repository of information about the world, often represented in a formal language.\n  Inference Engine: Processes information from the knowledge base to draw conclusions and make decisions.\n  Sensors: Collect data from the environment.\n  Actuators: Execute actions based on conclusions drawn.\n    Reasoning techniques include logical and probabilistic reasoning.\n   Propositional Logic #    Propositional logic deals with propositions, which are statements that are either true or false.\n  Variables represent propositions, and logical connectives (AND, OR, NOT) are used to form compound propositions.\n  Propositional logic is suitable for expressing relationships and conditions in a simple, binary manner.\n   Inference #    Inference is the process of deriving new information from existing knowledge.\n  In propositional logic, inference can involve both deduction and induction.\n  Deductive inference derives conclusions that must be true if the premises are true, based on logical rules.\n  Inductive inference involves making generalizations based on patterns observed in specific examples.\n   Predicate Logic (First Order Logic) #    Predicate logic, or first-order logic, extends propositional logic by introducing variables, quantifiers, and predicates.\n  Variables represent objects, quantifiers (existential and universal) specify the scope of variables, and predicates represent relationships.\n  It allows for a more expressive representation of knowledge and is commonly used in AI.\n   Resolution #    Resolution is a logical inference technique in predicate logic.\n  It involves the resolution rule, which eliminates redundant clauses and facilitates the derivation of new clauses.\n  Resolution is a foundational step in automated theorem proving and logical reasoning.\n   Structured Knowledge Representation #   Frames #    Frames provide a structured way to represent knowledge about objects and concepts.\n  A frame consists of slots (attributes) and values associated with those slots.\n  Frames are used for organizing and representing complex, hierarchical relationships.\n   Semantic Nets #    Semantic nets, or semantic networks, offer a graphical representation of knowledge using nodes and links.\n  Nodes represent concepts, and links represent relationships between concepts.\n  Semantic nets provide a visual and intuitive representation of semantic relationships.\n   Planning #   A Simple Planning Agent #    A planning agent formulates and executes plans to achieve specific goals.\n  Components include:\n  Goal formulation: Defining the desired outcome.\n  Problem formulation: Representing the initial state, goal state, and possible actions.\n  Search for a solution: Exploring the state space to find a sequence of actions from the initial to the goal state.\n     From Problem Solving to Planning #    Planning involves reasoning about actions and their consequences to achieve goals.\n  In contrast to problem-solving agents, planning agents operate in dynamic environments with changing states.\n  Planning requires generating action sequences that transform an initial state into a desired goal state.\n   Basic Representation of Plans #    Plans are representations of sequences of actions or steps that an agent can execute to achieve a goal.\n  Plans can be represented as lists of actions or in a structured format.\n  A complete and feasible plan is necessary for achieving goals in dynamic environments.\n   Partial Order Planning #    Partial Order Planning allows for flexibility in the execution order of actions.\n  Instead of a strict linear order, actions are partially ordered based on dependencies and constraints.\n  Partial Order Planning is valuable in environments with uncertain action effects.\n   Hierarchical Planning #    Hierarchical Planning organizes plans into hierarchies with subgoals and subplans.\n  Subgoals are intermediate objectives contributing to the overall goal.\n  Hierarchical Planning simplifies the representation of complex plans.\n  ","date":"4 November 2023","permalink":"/ai-chapter/ai-chapter-2/","section":"AI-chapters","summary":"Knowledge, Reasoning \u0026amp; Planning #   Reasoning #   Knowledge-Based Agent #    A knowledge-based agent is a sophisticated system designed to utilize knowledge for decision-making and problem-solving.","title":"AI chapter-2"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]